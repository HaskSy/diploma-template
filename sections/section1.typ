#import "../lib.typ": *

= Анализ языка Cangjie и проблематики

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Также будут рассмотрены на примерах возможности языка в написании @dsl:pl
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

#definition("Copy On Write") [ TODO ]
#definition("Композируемость") [ TODO ]
#definition("Объект первого класса") [ ТODO ]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Properties
=== Замыкания и инлайнинг
=== Области видимости и приватность
=== Инвариантный параметрический полиморфизм
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблематики
На данный момент, ни семантика языка @cangjie, ни стандартная библиотека, ни сообщество языка не предоставляют удобного интерфейса для сразу нескольких проблем: отсутствует поддержка интерфейса создания новых версий неизменяемых структур данных; нет удобного метода создания копии изменяемого объекта для его последующей модификации, без воздействия на оригинал; оперирование значениями, хранящимися в сложных струкрурах данных, также затруднительно. Наличие пользовательсоко интерфейса для решения данных и подобных проблем, упростило бы написание программ в функциональной парадигме, поддерживаемой языком.

В этом разделе мы рассмотримпримеры, на которых заметна нехватка выразительности. Когда код, который необходимо написать -- достаточно шаблонный, но интерфейс за которым этот код мог бы быть скрыт -- отсутсвует

=== Персистентный интерфейс

#definition("Персистентный интерфейс")[
    набор операций для работы с данными, гарантирующий, что любое изменение порождает новую версию данных
]

Проблема персистентной модификации неизменяемых объектов возникает в языке, в той или иной степени, со всеми неизменяемыми типами данных. Рассмотрим несколько проблемных примеров
==== Кортеж
Предположим, что запись из базы данный представляется кортежом. Модификация уже существующего кортежа, подразумевает ручное обращение ко всем аргументам, которые не будут меняться, для их перезаписи в новых кортеж, и лишь единицы из всего набора значений будут изменены
```cangjie
type TableRecord = (String, Int64, Int64, String, ...) 

func updateSecond(r: TableRecord, newval: Int64): TableRecord {
    let (s1, _, i2, s2, ...) = r
    return (s1, newval, i2, s2, ...)
}
```
Проблема уcугубляется тем, что нет возможности описать полиморфный, по числу аргументов кортежа метод.

==== Тип-перечисление
Схожей проблемой обладают и типы-перечисления. когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения.

Предположим, что у нас есть некая структура `ProgressData`, будем использовать `enum ProgressState` как некий маркер сообщающий о том, из какого контекста эти данные к нам поступили. Тогда при модификации `ProgressData` нам необходимо сначала выполнить сопоставление с образцом, и лишь потом писать бизнес-логику вычисления обновленного значения

```cangjie
public enum ProgressState {
    | Ready(ProgressData)
    | Active(ProgressData)
    | Completed(ProgressData, DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(ProgressData, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready(ProgressData()) // начальное состояние
    // ...
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // ...
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```

==== `struct`
Тип данных `struct`, также не избавлен от этой проблемы полностью. Покажем примере структуры, у которой все поля помечены `let`:
```cangjie
public struct LargeStruct {
    public LargeStruct(
        let x: String,
        let y: String,
        ...
    ) { }
}
```

@cow в данной ситуации мы воспользоваться не сможем. Если мы хотим построить новую версию структуры, нам прийдется, также, как и в случае с кортежем, прочитать все поля и склонировать их.
```cangjie
main(): Unit {
    let immutable = LargeStruct("Hello", "World", ...)
    let updated = LargeStruct("Bye", immutable.y, ...)
    concurrentMethod(immutable)
    concurrentMethod(updated)
}
```

=== Работа со сложными структурами данных

#definition("Сложная структура данных")[]

Рассмотрим следующий пример. Мы хотим поднять зарплату сотруднику по имени *Mark* из нашего департамента. Однако, мы должны сделать это транзакционно, с сохранением предыдущей версии:

Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

Код подобной сложности потребует
#enum(
    [Определение столбцов нужного типа],
    [Создание новой реляционной таблицы, для записи с обновленными типами],
    [Перенос незатронутых значений без изменений],
    [Модификация обновленных значений]
)

```cangjie
struct Employee {
    let name: String
    let salary: BigDecimal
}

struct Department {
    let employees: Array<Employee>
}
```

Императивный код данного решения, выглядел бы следующим образом:
```cangjie
let updated = ArrayList<Employee>()
var found = false

for (e in department.employees) {
    if (!found && e.name == "Mark") {
        updated.add(
            Employee(e.name, e.salary * 1.1)
        )
    	found = true
    } else {
        updated.add(e)
    }
}

let newDep = Department(
    department.name,
    updated.toArray()
)
```

=== View-Update фреймворк
// *NOTE: тут полнейшая терминологическая каша, надо очень аккуратно ввести термины Модель Данных, Представление, Промежуточне представление, Процедура обновления, итд, и чтобы они были согласованы с тем, что уже установлено. Я вот до сих пор не до конца понимаю, что люди в различной литературе имеют ввиду под моделью данных. Иногда я не могу отличить это от представления. Типа... Если у нас представление представления, то первое представление - модель данных для второго представления? Или как*

Для дальнейшего обсуждения, потребуется ввести набор вспомогательных определений, схожих с теми, что вводятся в предметной области реляционных моделей данных.

#definition("Представление (view)")[
    Репрезентация данных, с целью: предоставления интерфейса взаимодействия с ними, изоляции сложности, сокрытия части данных, и т.д.
]
#definition("Процедура обновления")[
    Подпрограмма, транслирующая изменения представления на данные, "лежащие" за этим представлением
]

Одни и те же данные, в различных контекстах использования, фигурируют в различных представлениях. Конечное представление, в свою очередь, может быть выражено через цепочку из нескольких представлений. В подобной ситуации, у пользователя рано или поздно возникает необходимость в поддержании консистентности между представлениям и консистентностю данных, "лежащих" под ними. Обычно, это решается путем обновления данных через представления, что приводит нас к *проблеме View-Update*

#definition("Проблема View-Update")[
    Проблема, гласящая, что, в общем случае, нет однозначно определяемой процедуры обновления оригинальных данных через их представление
]
// NOTE: Читать как: "не все отношения, в общем случае, являются инъективными"
Проблема View-Update может возникнуть, например, в ситуациях когда записи из разных источников приводятся к одному представлению. Из-за этого мы не можем, имея только представление, определить, из какого источника была получена запись

Несмотря на то, что в оригинале проблема была сформулирована для реляционных баз данных @database_views, она может возникнуть в любой иной задаче, подразумевающей оперирование данными и их представлениями. Пример: сериализация, синхронизация и т.д. @usecases_citation.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно.

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unit {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

Написав подобный код, мы сохнарили консистентность между сущностью `ProgressData` и `JSON`, из которого она была получена. Однако, было бы неплохо иметь общий механизм синхронизации представлений, чем описывать его попарно для каждого представления вручную. Одним из решений данной проблемы является *View-Update фреймворк*.

#definition("View-Update фреймворк")[
    Абстракция, предоставляющая функциональность генерации процедур обновления данных по представлению и интерфейс для описания процедур обновления в случаях, когда фреймворк не способен их сгенерировать
]

Идея View-Update фреймворка была сформулирована ранее @matsuoka_framework. Добавление View-Update фреймворка на уровне языка/стандартной библиотеки предоставило бы возможности для бесшовного взаимодействия между представлениями различных библиотек. В то же время позволяя разработчикам описывать свои представления независимо друг от друга

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.
== "Оптика"
Как мы увидели, есть множество разносортных проблем, для которых отсутствует элегантный способ их преодоления в языке. Однако, для них всех, существует общее идиоманичное решение, именуемое #gls("optics", display: ["Оптикой"])#footnote[
В литературе, @optics также встречается под названием *bidirectional transformation (bx)*, как их частный случай @database_views@pierce_framework.
]

#definition(["Оптика"])[
    Абстракция, хранащая информацию о способе доступа, модификации, обхода сложных структур данных
]
@optics, в том виде, в котором она существует в функциональном программировании, решает задачу предоставления удобного интерфейса для модификации неизменяемой структуры данных --- подобие "cсылки" на позиции внутри структур.

Область применения #gls("optics", display: ["Оптики"]) меняется в объекто-ориентированных языках --- во главу угла встает изменяемое состоятие и, если возникает необходимость построить новую версию сущности, без изменения состояния оригинала, то мы либо:
#list(
  [Заменяем сущность на её персистентный аналог],
  [Предоставляем обертку, имеющую персистентный интерфейс]
)

В то время как, декларативное описание операции через #gls("optics", display: ["Оптикy"]) выглядело бы так:
```cangjie
let newDep = Optics.compose(
    lensEmpoyees,
    selectFirst(
        e => e.name == “Mark”
    ),
    lensSalary
).modify(
    department,
    salary => salary * 1.1
)
```
@optics, здесь --- обертка с одним методом, которая сразу же исполняется, как только получила оборачиваемый объект на вход

Таким образом, добавление #gls("optics", display: ["Оптики"]), решило бы первые две проблемы языка по принципу её построения. 

Что касается проблемы View-Update --- в соответствующих работах, были сформулированы идеи реализации View-Update фреймворка на базе механизма #gls("optics", display: ["Оптики"]) @pierce_framework.

Таким образом, мы постулируем, что @optics обязана удовлетворять следующим свойствам:
#list(
    [Композируемость],
    [Объект первого класса],
    [Персистентны интерфейс]
)

// ```cangjie
// main(): Unit {
//     let dataModel = getResponse(request)
//     let composed = Optics.compose(
//         DeserializeAs<ProgressData>,
//         colorLens,
//         tupleSecond
//     )
//     let newDataModel = composed.modify(dataModel, 255)
// }
// ```

