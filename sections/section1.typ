#import "../lib.typ": *

= Анализ языка Cangjie и проблематики
#TODO[Напиши нормальное введение к главе]

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Будут введен основной набор определений...
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

Цитирование спеки @spec_web

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

#definition("Copy On Write") [ #TODO[] ]
#definition("Композируемость") [ #TODO[] ]
#definition("Объект первого класса") [ #TODO[] ]
#definition("Доменная модель") [ #TODO[] ]

=== #TODO[]
// === Процедурные макросы
// === Блоки-расширения
// === Струкруты/Классы/enum/кортежи
// === Properties
// === Замыкания и инлайнинг
// === Области видимости и приватность
// === Инвариантный параметрический полиморфизм
// === Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблематики
На данный момент, ни семантика языка @cangjie, ни стандартная библиотека, ни сообщество языка не предоставляют удобного интерфейса для сразу нескольких задач: отсутствует поддержка интерфейса создания новых версий неизменяемых структур данных; нет удобного метода создания копии изменяемого объекта для его последующей модификации, без воздействия на оригинал; оперирование значениями, скрытыми в глубине структуры, также затруднительно. Наличие пользовательсоко интерфейса для решения данных и подобных проблем, упростило бы написание программ в функциональной парадигме, поддерживаемой языком.

В этом разделе мы рассмотрим примеры, на которых заметна нехватка выразительности. Когда код, который необходимо написать -- достаточно шаблонный, но интерфейс, за которым этот код мог бы быть скрыт -- отсутсвует

=== Персистентный интерфейс

#definition("Персистентный интерфейс")[
    набор операций для работы с данными, гарантирующий, что любое изменение порождает новую версию данных
]

Проблема персистентной модификации неизменяемых объектов возникает в языке, в той или иной степени, со всеми неизменяемыми типами данных. Рассмотрим каждый из них на небольших примерах.
==== Кортеж
Предположим, что запись из базы данный представляется кортежом. Модификация уже существующего кортежа, подразумевает ручное обращение ко всем аргументам, которые не будут меняться, для их перезаписи в новых кортеж, и лишь единицы из всего набора значений будут изменены
```cangjie
type TableRecord = (String, Int64, Int64, String, ...) 

func updateSecond(r: TableRecord, newval: Int64): TableRecord {
    let (s1, _, i2, s2, ...) = r
    return (s1, newval, i2, s2, ...)
}
```
Проблема уcугубляется тем, что нет возможности описать полиморфный, по числу аргументов кортежа метод. То есть, если метод, каким либо образом, зависит на позиции элеменов в кортеже, должна быть написана перегрузка для каждого возможного размера кортежа, либо их разумное количество.

==== Тип-перечисление
Рассмотрим сценарий, когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения.

Предположим, что у нас есть некая структура `ProgressData`, будем использовать `enum ProgressState` как некий маркер сообщающий о том, из какого контекста эти данные к нам поступили. Тогда при модификации `ProgressData` нам необходимо сначала выполнить сопоставление с образцом, и лишь потом писать бизнес-логику вычисления обновленного значения

```cangjie
public enum ProgressState {
    | Ready(ProgressData)
    | Active(ProgressData)
    | Completed(ProgressData, DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(ProgressData, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready(ProgressData()) // начальное состояние
    // ...
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // ...
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```

==== `struct`
Тип данных `struct` можно персистентно обновлять с помощью синтаксиса "через точку", имеющего под собой @cow семантику, однако `struct` не избавлен от проблемы c персистентным обновленем полностью. Покажем примере структуры, у которой все поля помечены `let`:
```cangjie
public struct LargeStruct {
    public LargeStruct(
        let x: String,
        let y: String,
        ...
    ) { }
}
```

#noindent[Синтаксисом "через точку", в данной ситуации, мы воспользоваться не сможем. Если мы хотим построить новую версию структуры, нам придется, также, как и в случае с кортежем, прочитать все поля поименно и склонировать их.]
```cangjie
main(): Unit {
    let immutable = LargeStruct("Hello", "World", ...)
    let updated = LargeStruct("Bye", immutable.y, ...)
    concurrentMethod(immutable)
    concurrentMethod(updated)
}
```

=== Работа со сложными структурами данных

// TODO: Is that really necessary?
// #definition("Сложный тип данных")[
//     Тип данных, состоящий из других типов данных
// ]
#TODO[Перепиши этот раздел к херам, он очень плох]

Предположим, что у нас имеется "ветвистая" структура данных. В которой нам необходимо произвести модификацию значения, лежащего глубоко внутри неё. Пример: хотим поднять зарплату на 10% одному из сотрудников нашего департамента. Наша доменная модель будет выглядеть следующим образом:
```cangjie
public struct Employee {
    public Employee(
        let name: String,
        let salary: BigDecimal,
        ...
    ) { }
}

public struct Department {
    public Department(
        let employees: Array<Employee>,
        ...
    ) { }
}
```

#noindent[Императивный код для нашей операции, выглядел бы следующим образом:]
```cangjie
let updated = ArrayList<Employee>()
var found = false

for (e in department.employees) {
    if (!found && e.name == "Mark") {
        updated.add(
            Employee(e.name, e.salary * 1.1)
        )
    	found = true
    } else {
        updated.add(e)
    }
}

let newDep = Department(
    department.name,
    updated.toArray()
)
```
Есть сразу несколько вещей, которые мы могли бы улучшить в данном коде:
- *Размер кода* -- Данный пример кода нельзя назвать большим, однако, если бы глубина вложенности, на которую нам приходилось опускаться была больше, то код бы заметно вырос в размере.
- *Модульное построение пути обхода* -- наши структуры `Department/Employee`, могут хранить другие сложные структуры данных в своих полях, хотелось бы обобщить данный код по различным путям, которые мы можем выбрать. Сохранив при этом возможность, как читать, так и модифицировать значения

Если бы нам было достаточно возможности чтения, то @dsl наподобие `Java Stream API` было бы достаточно, однако, это не так.

// Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

// Код подобной сложности потребует
// #enum(
//     [Определение столбцов нужного типа],
//     [Создание новой реляционной таблицы, для записи с обновленными типами],
//     [Перенос незатронутых значений без изменений],
//     [Модификация обновленных значений]
// )



=== View-Update фреймворк
// *NOTE: тут полнейшая терминологическая каша, надо очень аккуратно ввести термины Модель Данных, Представление, Промежуточне представление, Процедура обновления, итд, и чтобы они были согласованы с тем, что уже установлено. Я вот до сих пор не до конца понимаю, что люди в различной литературе имеют ввиду под моделью данных. Иногда я не могу отличить это от представления. Типа... Если у нас представление представления, то первое представление - модель данных для второго представления? Или как*

Для дальнейшего обсуждения, потребуется ввести набор вспомогательных определений, схожих с теми, что вводятся в предметной области реляционных моделей данных.

#definition("Представление (view)")[
    Репрезентация данных, с целью: предоставления интерфейса взаимодействия с ними, изоляции сложности, сокрытия части данных, и т.д.
]
#definition("Процедура обновления")[
    Подпрограмма, транслирующая изменения представления на данные, "лежащие" за этим представлением
]

Одни и те же данные, в различных контекстах использования, фигурируют в различных представлениях. Конечное представление, в свою очередь, может быть выражено через цепочку из нескольких представлений. В подобной ситуации, у пользователя рано или поздно возникает необходимость в поддержании консистентности между представлениям и консистентностю данных, "лежащих" под ними. Обычно, это решается путем обновления данных через представления, что приводит нас к *проблеме View-Update*

#definition("Проблема View-Update")[
    Проблема, гласящая, что, в общем случае, нет однозначно определяемой процедуры обновления оригинальных данных через их представление
]
// NOTE: Читать как: "не все отношения, в общем случае, являются инъективными"
Проблема View-Update может возникнуть, например, в ситуациях когда записи из разных источников приводятся к одному представлению. Из-за этого мы не можем, имея только представление, определить, из какого источника была получена запись

Несмотря на то, что в оригинале проблема была сформулирована для реляционных баз данных @database_views, она может возникнуть в любой иной задаче, подразумевающей оперирование данными и их представлениями. Пример: сериализация, синхронизация и т.д. @usecases_citation.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно.

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unit {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

Написав подобный код, мы сохнарили консистентность между сущностью `ProgressData` и `JSON`, из которого она была получена. Однако, было бы неплохо иметь общий механизм синхронизации представлений, чем описывать его попарно для каждого представления вручную. Одним из решений данной проблемы является *View-Update фреймворк*.

#definition("View-Update фреймворк")[
    Абстракция, предоставляющая функциональность генерации процедур обновления данных по представлению и интерфейс для описания процедур обновления в случаях, когда фреймворк не способен их сгенерировать
]

Идея View-Update фреймворка была сформулирована ранее @matsuoka_framework. Добавление View-Update фреймворка на уровне языка/стандартной библиотеки предоставило бы возможности для бесшовного взаимодействия между представлениями различных библиотек. В то же время позволяя разработчикам описывать свои представления независимо друг от друга

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.
== "Оптика"
Как мы увидели, есть множество разносортных проблем, для которых отсутствует элегантный способ их преодоления в языке. Однако, для них всех, существует общее идиоманичное решение, именуемое #gls("optics", display: ["Оптикой"])#footnote[
В литературе, @optics также встречается под названием *bidirectional transformation (bx)*, как их частный случай @database_views@pierce_framework.
]

#definition(["Оптика"])[
    Абстракция, хранащая информацию о способе доступа, модификации, обхода сложных типов данных
]
@optics, в том виде, в котором она существует в функциональном программировании, решает задачу предоставления удобного интерфейса для модификации неизменяемых структур данных --- подобие "изменяемой cсылки" на позиции внутри структур.

Область применения #gls("optics", display: ["Оптики"]) меняется в объекто-ориентированных языках --- во главу угла встает изменяемое состоятие и, если возникает необходимость построить новую версию сущности, без изменения состояния оригинала, то мы либо:
#list(
  [Заменяем сущность на её персистентный аналог],
  [Предоставляем обертку, имеющую персистентный интерфейс]
)

Вспомним пример с сотрудником депатрамента. Декларативное описание данной операции через #gls("optics", display: ["Оптикy"]) выглядело бы так:
```cangjie
let newDep = Optics.compose(
    lensEmpoyees,
    selectFirst(
        e => e.name == “Mark”
    ),
    lensSalary
).modify(
    department,
    salary => salary * 1.1
)
```
Таким образом, добавление #gls("optics", display: ["Оптики"]), решило бы первые две проблемы языка: персистентное обновление и оперирование сложными типами данных, по принципу её построения. 

Что касается проблемы View-Update --- в соответствующих работах, были сформулированы идеи реализации View-Update фреймворка на базе механизма #gls("optics", display: ["Оптики"]) @pierce_framework.

// Таким образом, мы постулируем, что @optics обязана удовлетворять следующим свойствам:
// #list(
//     [Композируемость],
//     [Объект первого класса],
//     [Персистентны интерфейс]
// )

// ```cangjie
// main(): Unit {
//     let dataModel = getResponse(request)
//     let composed = Optics.compose(
//         DeserializeAs<ProgressData>,
//         colorLens,
//         tupleSecond
//     )
//     let newDataModel = composed.modify(dataModel, 255)
// }
// ```

