#import "../lib.typ": *

= Анализ предметной области

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке Cangjie. Также будут рассмотрены на примерах возможности языка @dsl:pl
== Язык Cangjie и его возможности
#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Замыкания
=== Properties
=== Инвариантный параметрический полиморфизм
=== Области видимости и приватность
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблемы и возможных решений
Если исключать из обсуждения `struct`, то, на данным момент, ни семантика языка @cangjie, ни его стандартная библиотека не предоставляют удобного интерфейса для пересоздания неизменяемых структур данных, на основе их текущиx значений, несмотря на сподвижеине языка, к написанию в функциональном стиле. Также, отсутствует удобный способ модификации изменяемого объекта, без смены его состояния. Модификация сложных структур данных, является проблематичной даже для `struct`, в случае, если полями являются любые струкруты данных, отличные от `struct`.

В этом разделе мы рассмотрим некоторые распространенные случаи, в которых заметна нехватка выразительности языка и в то же время, код, который необходимо написать, достаточно прост, но громоздок
=== Неизменяемые структуры данных
Стандартной, и достаточно распространенной неизменяемой структурой данных в языке, модификация которой, является затруднительной являются кортежи.

Допустим, что у нас, есть функция, считающая в какой цвет нам необходимо покрасить пиксель на экране, если мы работаем в цветовой схеме RGBA (кортеж из 4 элементов)

```cangjie
type RGBA = (UInt8, UInt8, UInt8, UInt8)
type RGB = (UInt8, UInt8, UInt8)

func blendColors(foreground: RGBA, background: RGBA): RGB {
    let fgAlpha = foreground[3] as Float32 / 255.0
    let bgAlpha = background[3] as Float32 / 255.0
    
    let blendedAlpha = fgAlpha + bgAlpha * (1.0 - fgAlpha)
    
    let blendChannel = { fg: UInt8, bg: UInt8 => 
        let fg = fg as Float32 * fgAlpha
        let bg = bg as Float32 * bgAlpha * (1.0 - fgAlpha)
        ((fg + bg) / blendedAlpha).round() as UInt8
    }
    
    return (
        blendChannel(foreground[0], background[0]),
        blendChannel(foreground[1], background[1]),
        blendChannel(foreground[2], background[2])
    )
}
```

Пусть, затем к цвету на экране, применится цветовой фильтр, максимизирующий зеленый цвет на экране. Чтобы модифицировать, уже существующий кортеж, пользователю приходится вручную обращаться ко всем аргументам кортежа, просто чтобы их записать в новом коржете с теми же значениями и лишь единицы из всего набора значений будут изменены
```cangjie
func greenFilter(color: RGB): RGB {
    let (r, _, b) = color
    return (r, 255, b)
}

main(): Unit {
    let fg: RGBA = (255, 0, 0 128)
    let bg: RGBA = (0, 0, 255, 255)
    let blended = blendColors(fg, bg)
    let updated = greenFilter(blended)
}
```

Схожей проблемы обладют и типы-перечисления, когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения
```cangjie
public enum ProgressState {
    | Ready
    | Active(ProgressData)
    | Completed(DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(String, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```
=== Композирование изменений
@optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами. Рассмотрим для примера интерфейс `JsonSerializable<T>`
=== Пользовательская "Оптика"
=== Персистентные коллекции

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать дизайн "Оптики" для языка @cangjie на основании опыта других языков и реализовать поддержку "Оптики" в компиляторе `cjc`. Провести анализ текущего решения]

#let objectives(..obj) = {
    strong("Задачи: ")
    set enum(indent: 1.5em)
    enum(..obj)
}

#objectives(
    [Провести анализ существующих решений в функциональных и объектно-ориентированных языках программирования],
    [Провести анализ текущих ограничений языка @cangjie],
    [Реализовать версию "Оптики" на языке @cangjie на основании],
    [Реализовать не библиотеко-специфичные компиляторные оптимизации, улучшающие быстродействие реализации],
    [Определить вектор развития языка, упрощающий реализацию подобных @dsl в будущем])
