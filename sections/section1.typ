#import "../lib.typ": *

= Анализ предметной области

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Также будут рассмотрены на примерах возможности языка @dsl:pl
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Properties
=== Замыкания и инлайнинг
=== Области видимости и приватность
=== Инвариантный параметрический полиморфизм
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблемы и возможных решений
Если исключать из обсуждения `struct`, то, на данным момент, ни семантика языка @cangjie, ни его стандартная библиотека не предоставляют удобного интерфейса для пересоздания неизменяемых структур данных, на основе их текущего состояния, несмотря на поддержание функционального стиля написания программ. Также, отсутствует удобный способ создания копии изменяемого объекта с изменением состояния, без модификаций в оригинале. Оперирование значениями, хранящихся в сложных структурах данных, является проблематичным даже в случае `struct`, если полями являются любые струкруты данных, отличные от `struct`. Например, мы хотим воспользоваться @cow семантикой объекта `struct`, однако объект, который мы модифицируем, хранится на куче и хранится в `struct` по ссылке, таким образом меняя состояние в старом объекте

В этом разделе мы рассмотрим некоторые распространенные случаи, в которых заметна нехватка выразительности языка и в то же время, код, который необходимо написать, достаточно прост, но громоздок
=== Неизменяемые структуры данных
Стандартной, и достаточно распространенной неизменяемой структурой данных в языке, модификация которой, является затруднительной являются кортежи.

Допустим, что у нас, есть функция, считающая в какой цвет нам необходимо покрасить пиксель на экране, если мы работаем в цветовой схеме RGBA (кортеж из 4 элементов)

```cangjie
type RGBA = (UInt8, UInt8, UInt8, UInt8)
type RGB = (UInt8, UInt8, UInt8)

func blendColors(foreground: RGBA, background: RGBA): RGB {
    let fgAlpha = foreground[3] as Float32 / 255.0
    let bgAlpha = background[3] as Float32 / 255.0
    
    let blendedAlpha = fgAlpha + bgAlpha * (1.0 - fgAlpha)
    
    let blendChannel = { fg: UInt8, bg: UInt8 => 
        let fg = fg as Float32 * fgAlpha
        let bg = bg as Float32 * bgAlpha * (1.0 - fgAlpha)
        ((fg + bg) / blendedAlpha).round() as UInt8
    }
    
    return (
        blendChannel(foreground[0], background[0]),
        blendChannel(foreground[1], background[1]),
        blendChannel(foreground[2], background[2])
    )
}
```

Пусть, затем к цвету на экране, применится цветовой фильтр, максимизирующий зеленый цвет на экране. Чтобы модифицировать, уже существующий кортеж, пользователю приходится вручную обращаться ко всем аргументам кортежа, просто чтобы их записать в новом коржете с теми же значениями и лишь единицы из всего набора значений будут изменены
```cangjie
func greenFilter(color: RGB): RGB {
    let (r, _, b) = color
    return (r, 255, b)
}

main(): Unit {
    let fg: RGBA = (255, 0, 0 128)
    let bg: RGBA = (0, 0, 255, 255)
    let blended = blendColors(fg, bg)
    let updated = greenFilter(blended)
}
```

Схожей проблемы обладют и типы-перечисления, когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения
```cangjie
public enum ProgressState {
    | Ready
    | Active(ProgressData)
    | Completed(DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(String, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```
=== Операции над представлениями
TODO - написать мотивацию и что я имел тут ввиду

// Я понимаю юзкейс, но я не могу сформулировать имя для задачи
Данная задача возникает в библиотеках сериализации, библиотеках работы с базами данных, RPC и т.д. Предоставление некого фреймворка, работы с даннымы на уровне языка/стандартной библиотеки предоставит возможность для бесшовной взаимодействия между моделями данных различныx библиотек, использующими этот фреймворк.

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unin {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

=== Работа со сложными структурами данных
TODO - мотивация

Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

Код подобной сложности потребует
#enum(
    [Определение столбцов нужного типа],
    [Создание новой реляционной таблицы, для записи с обновленными типами],
    [Перенос незатронутых значений без изменений],
    [Модификация обновленных значений]
)
```cangjie
// TODO...
```
=== Персистентность
Надо ли тут что-то писать?

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать дизайн #gls("optics", display: ["Оптики"]) для языка @cangjie на основании опыта других языков и реализовать поддержку #gls("optics", display: ["Оптики"]) в компиляторе `cjc`. Провести анализ итогового решения]

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ существующих решений в функциональных и объектно-ориентированных языках программирования],
    [Провести анализ текущих ограничений языка @cangjie],
    [Реализовать версию #gls("optics", display: ["Оптики"]) на языке @cangjie на основании проведенного анализа],
    [Реализовать не библиотеко-специфичные компиляторные оптимизации, улучшающие быстродействие реализации],
    [На основе результатов, определить возможный вектор развития для языка и функциональности]
)
