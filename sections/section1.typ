#import "../lib.typ": *

= Анализ языка Cangjie и проблематики

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Также будут рассмотрены на примерах возможности языка в написании @dsl:pl
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

#definition("Copy On Write") [ TODO ]
#definition("Композируемость") [ TODO ]
#definition("Объект первого класса") [ ТODO ]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Properties
=== Замыкания и инлайнинг
=== Области видимости и приватность
=== Инвариантный параметрический полиморфизм
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблематики
На данный момент, ни семантика языка @cangjie, ни стандартная библиотека, ни сообщество языка не предоставляют удобного интерфейса для сразу нескольких проблем: отсутствует поддержка интерфейса создания новых версий неизменяемых структур данных; нет удобного метода создания копии изменяемого объекта для его последующей модификации, без воздействия на оригинал; оперирование значениями, хранящимися в сложных струкрурах данных, также затруднительно. Наличие пользовательсоко интерфейса для решения данных и подобных проблем, упростило бы написание программ в функциональной парадигме, поддерживаемой языком.

В этом разделе мы рассмотримпримеры, на которых заметна нехватка выразительности. Когда код, который необходимо написать -- достаточно шаблонный, но интерфейс за которым этот код мог бы быть скрыт -- отсутсвует

=== Персистентный интерфейс

#definition("Персистентный интерфейс")[
    набор операций для работы с данными, гарантирующий, что любое изменение порождает новую версию данных
]

Проблема персистентной модификации неизменяемых объектов возникает в языке, в той или иной степени, со всеми неизменяемыми типами данных.

==== Кортеж
Предположим, что запись из базы данный представляется кортежом. Модификация уже существующего кортежа, подразумевает ручное обращение ко всем аргументам, которые не будут меняться, для их перезаписи в новых кортеж, и лишь единицы из всего набора значений будут изменены
```cangjie
type TableRecord = (String, Int64, Int64, String, ...) 

func updateSecond(r: TableRecord, newval: Int64): TableRecord {
    let (s1, _, i2, s2, ...) = r
    return (s1, newval, i2, s2, ...)
}
```
Проблема уcугубляется тем, что нет возможности описать полиморфный, по числу аргументов кортежа метод.

==== Тип-перечисление
Схожей проблемой обладают и типы-перечисления. когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения.

Предположим, что у нас есть некая структура `ProgressData`, будем использовать `enum ProgressState` как некий маркер сообщающий о том, из какого контекста эти данные к нам поступили. Тогда при модификации `ProgressData` нам необходимо сначала выполнить сопоставление с образцом, и лишь потом писать бизнес-логику вычисления обновленного значения

```cangjie
public enum ProgressState {
    | Ready(ProgressData)
    | Active(ProgressData)
    | Completed(ProgressData, DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(ProgressData, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready(ProgressData()) // начальное состояние
    // ...
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // ...
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```

==== `struct`
Тип данных `struct`, также не избавлен от этой проблемы полностью. Покажем примере структуры, у которой все поля помечены `let`:
```cangjie
public struct LargeStruct {
    public LargeStruct(
        let x: String,
        let y: String,
        ...
    ) { }
}
```

@cow в данной ситуации мы воспользоваться не сможем. Если мы хотим построить новую версию структуры, нам прийдется, также, как и в случае с кортежем, прочитать все поля и склонировать их.
```cangjie
main(): Unit {
    let immutable = LargeStruct("Hello", "World", ...)
    let updated = LargeStruct("Bye", immutable.y, ...)
    concurrentMethod(immutable)
    concurrentMethod(updated)
}
```

=== Работа со сложными структурами данных
TODO - перепиши этот раздел к херам

Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

Код подобной сложности потребует
#enum(
    [Определение столбцов нужного типа],
    [Создание новой реляционной таблицы, для записи с обновленными типами],
    [Перенос незатронутых значений без изменений],
    [Модификация обновленных значений]
)
```cangjie

```

=== View-Update фреймворк
// *NOTE: тут полнейшая терминологическая каша, надо очень аккуратно ввести термины Модель Данных, Представление, Промежуточне представление, Процедура обновления, итд, и чтобы они были согласованы с тем, что уже установлено. Я вот до сих пор не до конца понимаю, что люди в различной литературе имеют ввиду под моделью данных. Иногда я не могу отличить это от представления. Типа... Если у нас представление представления, то первое представление - модель данных для второго представления? Или как*

Для дальнейшего обсуждения, потребуется ввести набор вспомогательных определений, схожих с теми, что вводятся в предметной области реляционных моделей данных.

#definition("Представление (view)")[
    Репрезентация данных, с целью: предоставления интерфейса взаимодействия с ними, изоляции сложности, сокрытия части данных, и т.д.
]
#definition("Процедура обновления")[
    Подпрограмма, транслирующая изменения представления на данные, "лежащие" за этим представлением
]

Одни и те же данные, в различных контекстах использования, фигурируют в различных представлениях. Конечное представление, в свою очередь, может быть выражено через цепочку из нескольких представлений. В подобной ситуации, у пользователя рано или поздно возникает необходимость в поддержании консистентности между представлениям и консистентностю данных, "лежащих" под ними. Обычно, это решается путем обновления данных через представления, что приводит нас к *проблеме View-Update*

#definition("Проблема View-Update")[
    Проблема, гласящая, что, в общем случае, нет однозначно определяемой процедуры обновления оригинальных данных через их представление
]
// NOTE: Читать как: "не все отношения, в общем случае, являются инъективными"
Проблема View-Update может возникнуть, например, в ситуациях когда записи из разных источников приводятся к одному представлению. Из-за этого мы не можем, имея только представление, определить, из какого источника была получена запись

Несмотря на то, что в оригинале проблема была сформулирована для реляционных баз данных @database_views, она может возникнуть в любой иной задаче, подразумевающей оперирование данными и их представлениями. Пример: сериализация, синхронизация и т.д. @usecases_citation.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно.

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unit {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

Написав подобный код, мы сохнарили консистентность между сущностью `ProgressData` и `JSON`, из которого она была получена. Однако, было бы неплохо иметь общий механизм синхронизации представлений, чем описывать его попарно для каждого представления вручную. Одним из решений данной проблемы является *View-Update фреймворк*.

#definition("View-Update фреймворк")[
    Абстракция, предоставляющая функциональность генерации процедур обновления данных по представлению и интерфейс для описания процедур обновления в случаях, когда фреймворк не способен их сгенерировать
]

Идея View-Update фреймворка была сформулирована ранее @matsuoka_framework. Добавление View-Update фреймворка на уровне языка/стандартной библиотеки предоставило бы возможности для бесшовного взаимодействия между представлениями различных библиотек. В то же время позволяя разработчикам описывать свои представления независимо друг от друга

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.

#set heading(numbering: none)
== Заключение к главе

Как мы увидели, есть множество разносортных проблем, для которых отсутствует элегантный способ их преодоления в языке. Однако, для них всех, существует общее идиоманичное решение, именуемое #gls("optics", display: ["Оптикой"])

// ```cangjie
// main(): Unit {
//     let dataModel = getResponse(request)
//     let composed = Optics.compose(
//         DeserializeAs<ProgressData>,
//         colorLens,
//         tupleSecond
//     )
//     let newDataModel = composed.modify(dataModel, 255)
// }
// ```

