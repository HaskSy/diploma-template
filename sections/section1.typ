#import "../lib.typ": *

= Анализ предметной области

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Также будут рассмотрены на примерах возможности языка в написании @dsl:pl
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Properties
=== Замыкания и инлайнинг
=== Области видимости и приватность
=== Инвариантный параметрический полиморфизм
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблемы и возможных решений
На данный момент, ни семантика языка @cangjie, ни стандартная библиотека, ни сообщество языка не предоставляют удобного интерфейса для создания новых версий неизменяемых структур данных. Наличие такого интерфейса, упростило бы написание программ в функциональной парадигме, поддерживаемой языком. Также, отсутствует удобный способ создания копии изменяемого объекта и модификацией его, без воздействия на оригинал. Оперирование значениями, хранящимися в сложных структурах данных также затруднительно. Например, @cow семантика `struct` работает только если проиходит модификация типов-значений или подмена ссылок на объекты, аллоцированные на куче.

В этом разделе мы рассмотрим некоторые случаи, когда код, который необходимо написать -- достаточно шаблонный, однако способы его сокрытия за интерфейсом, на данный момент -- отсутствуют

=== Персистентный интерфейс
#definition("Персистентный интерфейс")[
    набор операций для работы с данными, гарантирующий, что любое изменение порождает новую версию данных
]

Проблема персистентной модификации неизменяемых объектов возникает в языке, в той или иной степени, со всеми неизменяемыми типами данных. В качестве первого примера рассмотрим кортеж.

Предположим, что строка базы данный представляется кортежом. Модификация уже существующего коржета, подразумевает ручное обращение ко всем аргументам, которые не будут меняться, для их перезаписи в новых кортеж, и лишь единицы из всего набора значений будут изменены
```cangjie
type TableRecord = (String, Int64, Int64, String, ...) 

func updateSecond(record: TableRecord, newval: Int64): TableRecord {
    let (s1, _, i2, s2, ...) = record
    return (s1, newval, i2, s2, ...)
}
```

Схожей проблемы обладют и типы-перечисления. когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения.

Предположим, что у нас есть некая структура `ProgressData`, будем использовать `enum ProgressState` как некий маркер сообщающий о том, из какого контекста эти данные к нам поступили. Тогда при модификации `ProgressData` нам необходимо сначала выполнить сопоставление с образцом, и лишь потом писать бизнес-логику вычисления обновленного значения

```cangjie
public enum ProgressState {
    | Ready(ProgressData)
    | Active(ProgressData)
    | Completed(ProgressData, DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(ProgressData, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready(ProgressData()) // начальное состояние
    // ...
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // ...
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```

Структуры также не избавлены от этой проблемы полностью. Рассмотрим следующую структуру:
```cangjie
public struct LargeStruct {
    public Test(
        let x: String,
        let y: String,
        ...
    ) { }
}
```
Если мы хотим построить новую версию структуры, мы должны также, как и в случае с кортежем, прочитать все поля и перенести/склонировать их. @cow в данной ситуации мы не сможем воспользоваться, так как поля помечены `let`
```cangjie
main(): Unit {
    let immutable = LargeStruct("Hello", "World", ...)
    let updated = LargeStruct("Bye", immutable.y, ...)
    concurrentMethod(immutable)
    concurrentMethod(updated)
}
```

=== Работа со сложными структурами данных
TODO - мотивация

Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

Код подобной сложности потребует
#enum(
    [Определение столбцов нужного типа],
    [Создание новой реляционной таблицы, для записи с обновленными типами],
    [Перенос незатронутых значений без изменений],
    [Модификация обновленных значений]
)
```cangjie

```

=== View-Update фреймворк
*NOTE: тут полнейшая терминологическая каша, надо очень аккуратно ввести термины Модель Данных, Представление, Промежуточне представление, Процедура обновления, итд, и чтобы они были согласованы с тем, что уже установлено. Я вот до сих пор не до конца понимаю, что люди в различной литературе имеют ввиду под моделью данных. Иногда я не могу отличить это от представления. Типа... Если у нас представление представления, то первое представление - модель данных для второго представления? Или как*

Одни и те же данные, могут фигурировать в коде в виде различных моделей, в зависимости от контекстах своего использования. В ситуации присутствия множества моделей/представлений, у пользователя, может возникнуть необходимость в поддержании их консистентности между собой и консистентности данных, "лежащих" под ними. 

#definition("Представление (view)")[ Репрезентация данных, с целью: изоляции сложности, сокрытия лишнего, предоставления дополнительного пользовательского интерфейса и т.д. ]
#definition("Процедура обновления")[ Подпрограмма, транслирующая изменения представления на данные, "лежащие" за этим представлением]
#definition("Проблема View-Update")[ Проблема, изначально возникшая в реляционных моделях данных, гласящая, что, в общем случае, нет однозначно определяемой процедуры обновления оригинальных данных через их представление ]

Несмотря на то, что основной областью изучения проблемы является область баз данных, она может возникнуть в любой иной задаче, подразумевающей оперирование данными и их моделями. Пример: сериализация, RPC и т.д. Одним из решений данной проблемы является *View-Update фреймворк*.

#definition("View-Update фреймворк")[ Абстракция, предоставляющая функциональность генерации процедур обновления данных и интерфейс для описания процедур обновления в случаях, когда фреймворк не способен их сгенерировать]


Предоставление *View-Update фреймворка* на уровне языка/стандартной библиотеки откроет способы бесшовного взаимодействия между моделями данных различных библиотек. В то же время позволяя разработчикам описывать свои модели независимо друг от друга

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unit {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать дизайн #gls("optics", display: ["Оптики"]) для языка @cangjie на основании опыта других языков и реализовать поддержку #gls("optics", display: ["Оптики"]) в компиляторе `cjc`. Провести анализ итогового решения]

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ существующих решений в функциональных и объектно-ориентированных языках программирования],
    [Провести анализ текущих ограничений языка @cangjie],
    [Реализовать версию #gls("optics", display: ["Оптики"]) на языке @cangjie на основании проведенного анализа],
    [Реализовать не библиотеко-специфичные компиляторные оптимизации, улучшающие быстродействие реализации],
    [На основе результатов, определить возможный вектор развития для языка и функциональности]
)
