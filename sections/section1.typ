#import "../lib.typ": *

= Анализ предметной области

В данной главе будет дан обзор концепиям и понятиям, существующим на данный момент в языке @cangjie. Также будут рассмотрены на примерах возможности языка в написании @dsl:pl
== Язык Cangjie и его возможности

#{
set text(hyphenate: true)
[#strong([@cangjie]) --- @oo, статически типизированный, язык программирования общего назначения, компилируемый в исполняемый код через инфраструктуру LLVM]
}

#definition("Система типов")[
  Гибко управляемый синтаксический метод доказательства
]
#definition("типов sf sdf sdf sd")[
  Гибко управляемый синтаксический метод доказательства
]

=== Процедурные макросы
=== Блоки-расширения
=== Струкруты/Классы/enum/кортежи
=== Properties
=== Замыкания и инлайнинг
=== Области видимости и приватность
=== Инвариантный параметрический полиморфизм
=== Инстанциирующий/Стирающий параметрический полиморфизм
== Описание проблемы и возможных решений
На данный момент, ни семантика языка @cangjie, ни стандартная библиотека, ни сообщество языка не предоставляют удобного интерфейса для создания новых версий неизменяемых структур данных. Наличие такого интерфейса, упростило бы написание программ в функциональной парадигме, поддерживаемой языком. Также, отсутствует удобный способ создания копии изменяемого объекта и модификацией его, без воздействия на оригинал. Оперирование значениями, хранящимися в сложных структурах данных. @cow семантика `struct` работает только если проиходит модификация типов-значений или подмена ссылок на объекты, аллоцированные на куче.

В этом разделе мы рассмотрим некоторые случаи, когда заметна нехватка выразительности языка, однако, код, который необходимо написать, достаточно шаблонный

=== Персистентный интерфейс
#definition("Персистентный интерфейс")[
    набор операций для работы с данными, гарантирующий, что любое изменение порождает новую версию данных
]

Достаточно распространенной неизменяемой структурой данных в языке, модификация которой, является затруднительной являются кортежи.

Допустим, что у нас, есть функция, считающая в какой цвет нам необходимо покрасить пиксель на экране, если мы работаем в цветовой схеме RGBA (кортеж из 4 элементов)

```cangjie
type RGBA = (UInt8, UInt8, UInt8, UInt8)
type RGB = (UInt8, UInt8, UInt8)

func blendColors(foreground: RGBA, background: RGBA): RGB {
    let fgAlpha = foreground[3] as Float32 / 255.0
    let bgAlpha = background[3] as Float32 / 255.0
    
    let blendedAlpha = fgAlpha + bgAlpha * (1.0 - fgAlpha)
    
    let blendChannel = { fg: UInt8, bg: UInt8 => 
        let fg = fg as Float32 * fgAlpha
        let bg = bg as Float32 * bgAlpha * (1.0 - fgAlpha)
        ((fg + bg) / blendedAlpha).round() as UInt8
    }
    
    return (
        blendChannel(foreground[0], background[0]),
        blendChannel(foreground[1], background[1]),
        blendChannel(foreground[2], background[2])
    )
}
```

Пусть, затем к цвету на экране, применится цветовой фильтр, максимизирующий зеленый цвет на экране. Чтобы модифицировать, уже существующий кортеж, пользователю приходится вручную обращаться ко всем аргументам кортежа, просто чтобы их записать в новом коржете с теми же значениями и лишь единицы из всего набора значений будут изменены
```cangjie
func greenFilter(color: RGB): RGB {
    let (r, _, b) = color
    return (r, 255, b)
}

main(): Unit {
    let fg: RGBA = (255, 0, 0 128)
    let bg: RGBA = (0, 0, 255, 255)
    let blended = blendColors(fg, bg)
    let updated = greenFilter(blended)
}
```

Схожей проблемы обладют и типы-перечисления, когда для создания нового значения типа, пользователю необходимо провести сопоставление с образцом и лишь потом писать бизнес-логику вычисления нового значения
```cangjie
public enum ProgressState {
    | Ready
    | Active(ProgressData)
    | Completed(DateTime<UTC>)
    | Paused(ProgressData)
    | Terminated(String, DateTime<UTC>)
}

main(): Unit {
    var progress = Ready
    // Логика, переключения между состояниями
    if (let Active(data) <- progress) {
        // Вычисление и обновление состояния
        data.percenatge += 1
        // Снятие задачи
        progress = Paused(data)
    }
    // ...
}
```

=== Работа со сложными структурами данных
TODO - мотивация

Рассмотрим немного искуственный, но, тем не менее демонстративный пример. Пускай, мы вызываем функцию `sqlQuery`, выполняющей запрос к реляционной базе данных. В качестве результата мы получаем, массив структур, где каждое поле струкруты представляет собой идентификатор столбца, затем, мы хотим обновить во всех полученных записях, все столбцы, имеющие тип `int` и модифицировать запись, заменив `int` на строку, представляющую собой, шестнадцатиричную запись этого числа.

Код подобной сложности потребует
#enum(
    [Определение столбцов нужного типа],
    [Создание новой реляционной таблицы, для записи с обновленными типами],
    [Перенос незатронутых значений без изменений],
    [Модификация обновленных значений]
)
```cangjie
// TODO...
```

=== Двунаправленные трансформации
Одни и те же данные, могут представляться через различные модели, в различных контекстах своего использования. В подобной ситуации, у пользователя, практически гарантированно, возникнет необходимость в поддержании консистентности этих моделей между собой. 

// Я понимаю юзкейс, но я не могу сформулировать имя для задачи
Данная задача возникает в библиотеках сериализации, библиотеках работы с базами данных, RPC и т.д. Предоставление некого фреймворка, работы с даннымы на уровне языка/стандартной библиотеки предоставит возможность для бесшовной взаимодействия между моделями данных различныx библиотек, использующими этот фреймворк.

// @optics позволяет описание композируемых операций над объектами. В том числе, работа с их промежуточными представлениями, как с оригинальными объектами.

Рассмотрим для примера интерфейс `JsonSerializable<T>`. Предположим, что у нас имеется объект `ProgressData`, поступающий нам на вход в виде `JSON`. Мы допустим, что мы хотим модифицировать объект, в его поле `color` и сериализовать объект обратно

```cangjie
struct ProgressData <: JsonSerializable<ProgressData> {
    public ProgressData(
        public let percenatge: UInt8,
        public let color: RGB,
        public let message: String
    ) { }
    
    public func serialize(): JsonDataModel { ... }
    public static func deserialize(dm: JsonDataModel) { ... }
}

main(): Unit {
    // ...
    let dataModel = getResponse(request)
    let current = ProgressData.deserialize(dataModel)
    let (r, _, b) = current.color
    let new = ProgressData(
        current.percenatge,
        (r, 255, b),
        current.message)
    let newDataModel = new.serialize()
    // ...
}
```

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать дизайн #gls("optics", display: ["Оптики"]) для языка @cangjie на основании опыта других языков и реализовать поддержку #gls("optics", display: ["Оптики"]) в компиляторе `cjc`. Провести анализ итогового решения]

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ существующих решений в функциональных и объектно-ориентированных языках программирования],
    [Провести анализ текущих ограничений языка @cangjie],
    [Реализовать версию #gls("optics", display: ["Оптики"]) на языке @cangjie на основании проведенного анализа],
    [Реализовать не библиотеко-специфичные компиляторные оптимизации, улучшающие быстродействие реализации],
    [На основе результатов, определить возможный вектор развития для языка и функциональности]
)
