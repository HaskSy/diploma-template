#import "../lib.typ": *

= Реализация в языке Cangjie

В предыдущей главе мы провели анализ предметной области "Оптики", рассмотрев существующий интерфейс, теоретические модели, позволяющие реализовать этот интерфейс и реализации в промышленных языках. Теперь мы готовы к тому, чтобы реализовать "Оптику" в @cangjie, с учетом его особенностей и ограничений.

Были выставлены следующие требования к дизайну и реализации конечного решения:
- Производительность --- отсутствие или низкая цена абстракции в сравнении с кодом, написанным без "Оптики".
- Работать при динамической линковке, как внешней зависимости
- Работать с различными уровнями видимости --- #TODO[Расписать теоретическое далее]
- Поддержать кодогенерацию "Оптики" для тривиальных случаев
- Лаконичный интерфейс взаимодействия
- Поддержать возможность написания пользовательской "Оптики"
- Объект первого класса

#noindent[
  Далее будут #TODO[А сначала напиши, а потом скажи, что будет]
]
== Дизайн API
В соответствии с задачами, поставленными перед прототипом в первой главе и в соответствии с особенностями языка, иерархия была уменьшена и представлена на @reduced_hierarchy[диаграмме].
#figure(
  image("../attachments/figures/reduced_hierarchy.png", width: 45%),
  caption: [ Иерархия #gls("optics", display: ["Оптики"]) прототипа],
  placement: auto
) <reduced_hierarchy>
#definition("Аппликативный функтор")[#TODO[]]
Из иерархии (@classic_hierarchy[Рисунок]) были убраны `Fold`, `Getter` и `Traversal`. `Traversal` (вследствии этого `Fold`) был исключен из иерархии из-за отсутствия в @cangjie понятия аппликативного функтора. Если у пользователя возникнет необходимость в реализации, фокусирующейся над несколькими элементами, то он сможет это сделать с помощью `Setter` "Оптики", и вручную описать процесс. `Getter` же, был исключен, так как в @cangjie, в отличие от функционального языка, это понятие уже присутствует и подходящих сценариев применения найдено не было. #TODO[Примеры] #TODO[Пример Kotlin Arrow, который добавил их зачем-то https://arrow-kt.io/learn/immutable-data/traversal/ хотя это просто дефолтные реализации setter для stdlib. Опять же, понятия аппликативного функтора в Kotlin нет, так что открытый вопрос - нахера?]

В качестве выигрыша мы получаем более простую иерархию, в которой любой существующий вид "Оптики" композируется с любым другим видом "Оптики", тем самым избавляя нас от исключителных случаев

#TODO[Полимофрная/мономорфная оптика. Выбор в пользу мономорфной. Проблемы инференса]
#TODO[Выбор генерируемой оптики. Область видимости. Просто перекопирут тот Obsidian, что был.]

== Выбор модели
#TODO[В данном разделе мы определимся в выбором моделью, замерим производительности моделей. Выбор модели будет определять пользовательский интерфей]
#TODO[Нет никакого более надежного способа выбрать модель чем написать её]
=== `getter`/`setter` модель и её проблемы
Дабы исследовать возможности языка, была написана версия "Оптики", использующая под собой `getter`/`setter` модель и интерфейсы в соответствии с определенной нами иерархией. Ниже приведен пример одного из интерфейсов `Lens<S, A>`, другие интерфейсы реализовывались аналогичным образом. #TODO[Приложение с интерфейсами? Перенести это в листинг?]

```cangjie

sealed interface Lens<S, A> <: Optionals<S, A> {
    prop view: (S) -> A
    prop update: (S, A) -> S
    prop preview: (S) -> Either<S, A> {
        get() { { source: S => Right(view(source)) } }
    }
}

private struct ValueLens<S, A> <: Lens<S, A> {
    ValueLens(
        private let _view: (S) -> A,
        private let _update: (S, A) -> S
    ) { }

    public prop view: (S) -> A {
        get() { _view }
    }

    public prop update: (S, A) -> S {
        get() { _update }
    }
}
```

Композиция выполняется с помощью специальной публичной функции `compose`:
```cangjie

public func compose<S, A, B>(l1: Lens<S, A>, l2: Lens<A, B>): Lens<S, B> {
    ValueLens(
        { source: S => l2.view(l1.view(source)) },
        { source: S, focus: B => l1.update(source, l2.update(l1.view(source), focus)) }
    )
}
```

==== Пример и бенчмаркинг
В качестве простейшего теста производительности для данной и далее описываемых моделей выступает следующая пара структур. Наша задача -- заменить `"Old"` на `"New"`, внутри неизменяемой переменной `bow`. Если результаты на данном тесте нас будут удовлетворять, то будем переходить к более сложным тестам.

#noindent[
```cangjie
public struct A {
    public A(
        public var x: B,
        public var y: String
    ) { }
}

public struct B {
    public B(
        public var x: String,
        public var y: String
    ) { }
}

let bow = A(B("Brave", "Old"), "World")
```

В языке подобное можно сделать достаточно простым кодом, используя @cow семантику, предоставляемую структурами. Либо пересобрать, вызывая конструкторы

```cangjie
var _tmp = bow
_tmp.x.y = "New"
let bnw = _tmp
```

"Оптика", которую нам необходимо сгенерировать для пути `bow.x.y` выглядит следующим образом
```cangjie
public let lensAx = createLens(
    { source: A => source.x },
    { source: A, focus: B => A(focus, source.y) }
)

public let lensBy = createLens(
    { source: B => source.y },
    { source: B, focus: String => A(source.x, focus) }
)
```
Либо, мы можем написать специально для этого пути отдельную "Оптику", которая использует @cow семантику структуры
```cangjie
public let best = createLens(
  { source: A => source.x.y },
  { source: A => focus: String =>
      var tmp = source
      tmp.x.y = focus
      tmp
  }
)
```

В #TODO[Перенести в листинг] представлен пример теста производительности, написанного с помощью предоставляемого стандартной библиотекой фреймворка.
```cangjie
@Test
@Configure[baseline: "nativeBaseline"]
class StructMutBenchmark {
    @Bench
    func nativeBaseline(): Unit {
        var bnw_ = bow
        bnw_.x.y = "New"
        let bnw = bnw_
        test = bnw
    }

    @Bench
    func opticsBaseline(): Unit {
        let bnw = composed.update(bow, "New")
        test = bnw
    }

    @Bench
    func bestOptics(): Unit {
        let bnw = composed.update(bow, "New")
        test = bnw
    }

    @AfterAll
    func aa(): Unit {
        let _ = test
    }
}
```

Результаты данного теста представлены в таблице ниже
#figure(
  three-line-table[
    | Сценарий           |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :----------------- | -------: | ----------: | -------: | ------------: |
    | baseline           | 2.527 ns | ±0.0124 ns  | 2.527 ns |          100% |
    | "Оптика"           | 1489  ns | ±24.6 ns    | 1271  ns |     +50149.7% |
    | update = baseline  | 112.1 ns | ±2.053 ns   | 125.2 ns |      +4852.0% |
  ],
  caption: [ Тест производительность `getter`/`setter` модели ],
)
#TODO[Указать где-то параметры бенчмарка. 1s прогрев, 200 батчей, ожидаемое время исполнения: 5s]
После дальнейшего анализа assembler для функции `opticsBaseline` было обнаружено большое количество `lea` инструкций, которые, в данном сценарии, используются для подгрузки содержимого из адресов, по которым расположены построенные нами замыкания. Это является индикатором того, что у языка возникли проблемы с инлайнингом вызовов замыканий.
]

Дальнейший анализ для функции `bestOptics`, других примеров и изменение thresholdов инлайнинга в фронтенде компилятора указывает на то, что @cangjie никогда не выполняет инлайнинг для любых замыканий, хранящихся внутри полей структуры.
#figure(
  three-line-table[
    | Сценарий           |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :----------------- | -------: | ----------: | -------: | ------------: |
    | baseline           | 2.529 ns | ±0.0103 ns  | 2.534 ns |          100% |
    | "Оптика"           | 1136  ns | ±9.08 ns    | 1276  ns |     +50356.0% |
    | update = baseline  | 109.2 ns | ±4.660 ns   | 126.5 ns |      +4911.3% |
  ],
  caption: [ Результаты теста производительности после увеличения всех `threshold` в 100 раз. Изменений нет ],
)

#TODO[Рассказать прикол, как увеличение `threshold`ов ломает вывод типов в `stdlib`]
На данном этапе возникает выбор либо править данное поведение в компиляторе, либо использовать другие модели "Оптики", с целью улучшения инлайнинга. Было решено исследовать второй путь и в случае отрицательных результатов - вернуться к идее о правках в компиляторе. #TODO[Рассказать почему не пошли в компилятор дальше]

=== модель ван Лаарховена
Как было сказано нами ранее, модель ван Лаарховена инлайнится лучше, чем `getter`/`setter` модель, так как целиком опирается на композицию функций высших порядков. Однако, @cangjie не является чисто функциональным языком, что может привести нас к ограничениям.

Заместо алгебраических типов данных мы будет использовать структуры с generic-параметрами
```cangjie
public struct Const<T, X> {
    public Const(
        public let value: T
    ) { }
}

public struct Identitiy<T> {
    public Identitiy(
        public let value: T
    ) { }
]
```

Классы типов, являются одним из способов реализации ad-hoc полиморфизма. В качестве альтернативы, в языке с этой целью выступает механизм перегрузок функций.
```cangjie

func fmap<X, Y, A>(_: (X) -> Y, a: Const<A, X>): Const<A, Y> {
    Const(a.value)
}
func fmap<A, B>(_: (A) -> B, a: Identitiy<A>): Identitiy<B> {
    Identitiy(f(a.value)}
```

#noindent[
Момент на котором у нас возникает проблема -- необходимость создать оптику. Метод `createLens` имеет следующую сигнатуру:

```haskell createLens :: (s -> a) -> (s -> a -> s) -> (a -> f a) -> s -> f s```
В @cangjie первые два аргумента будут входными агрументами фукнции. В возвращаемом значении возникает неизвестный функтор `f`, который может принимать либо тип `Const<T, X>`, либо тип `Identitiy<T>`. Однако в языке отсутствует higher-kinded полиморфизм и отсутствует перегрузка по возвращаемому значению. Ничего не мешает нам получить функцию ```haskell (a -> f a) -> s -> f s```, однако мы должны заранее знать то, как именно она будет использоваться, для получения значения или для его модификации. Например:
  - разделить фукнцию на две `createLensReader`, `createLensWriter`
  - дополнительный парамерт, определяющий тип функтора `f`.
Это лишает нас возможности использования эту модель "Оптики", как объект первого класса.
==== Тест производительности
#TODO[Добавить листинг]
#figure(
  three-line-table[
    | Сценарий                                     |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :------------------------------------------- | -------: | ----------: | -------: | ------------: |
    | baseline                                     | 2.685 ns | ±0.552 ns   | 3.004 ns |          100% |
    | модель ван Лаарховена                        | 86.83 ns | ±1.764 ns   | 87.29 ns |      +3151.3% |
    | модель `getter`/`setter` (update = baseline) | 140.0 ns | ±3.987 ns   | 141.1 ns |      +5154.8% | ],
  caption: [ Результаты теста производительности для модели ван Лаарховена ],
)
]
Значительное улучшение, в сравнении с предыдущей моделью. "Оптика" из текущей модели, построенная через композицию функций, которые можно генерировать независимо друг от друга работает быстрее, чем специально написанная под тест "Оптика" на основе предыдущей модели.

#noindent[
Проведем дополнительную серию тестов производительности, где мы генерируем структуры различной глубины вида:
```
let bow = A0(A1(...(An_1(An("Brave", "Old"), "World"), ...), "World"), "World")
```
Задача прежняя --- заменить "Old" на "New". Был проведен тест, замеряющий результаты вплоть до глубины вложености 15, однако рассмотрим только глубины 2,3 и 5.

#figure(
  table(
    columns: 2,
    [#v(3.4em)*Глубина 2*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :--------------| -------: | ---------: | -------: | ------: |
| baseline       | 2.616 ns |  ±0.250 ns | 3.068 ns |    100% |
| ван Лаарховен  | 8.553 ns |  ±0.151 ns | 8.329 ns | +218.4% |
| конструкторы   | 2.684 ns | ±0.025 ns | 2.728 ns |   +4.3% |
      ]],
    
    [#v(3.4em)*Глубина 3*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
|:---------------|---------:|----------:|---------:|--------:|
| baseline       | 63.95 ns | ±1.854 ns | 65.54 ns |    100% |
| ван Лаарховен  | 134.2 ns | ±7.874 ns | 142.2 ns | +122.3% |
| конструкторы | 13.14 ns | ±0.412 ns | 12.61 ns |  -80.3% |
    ]],
    
    [#v(3.4em)*Глубина 5*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :------------- | -------: | ---------: | -------: | ------: |
| baseline       | 65.21 ns |  ±0.718 ns | 65.12 ns |    100% |
| ван Лаарховен  | 534 ns   | ±15.8 ns | 518 ns   | +694.0% |
| конструкторы   | 15.55 ns |  ±0.775 ns | 15.49 ns |  -76.2% |
      ]],
    stroke: (x: 0pt, y: 0pt),
    align: (center, center),
    inset: 5pt,
  ),
  caption: [Тест производительности модели для различных глубин. Структуры и работа с ними происходят в одном пакете]
)
По неведомой причине, @cow семантика для данного конкретного примера оказывается медленнее, чем вызов конструкторов вручную. Несмотря на то, что все типы данных (`String`) неизменяемые. Это, определенно, баг в языке, и не связан напрямую с "Оптикой", однако, это также означает, что если нам удастся заинлайнить и проредуцировать "Оптику" до того же кода, что и вызов конструкторов, то "Оптика", может быть потенциально быстрее чем @cow. Причем, вне зависимости от места определения структур
#figure(
  table(
    columns: 2,
    [#v(3.4em)*Глубина 2*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :--------------| -------: | ---------: | -------: | ------: |
| baseline       | 2.535 ns | ±0.00750 ns | 2.544 ns |     100% |
| ван Лаарховен  | 83.21 ns |   ±1.672 ns | 87.65 ns | +3358.0% |
| конструкторы   | 2.534 ns |  ±0.0104 ns | 2.544 ns |    +0.4% |
      ]],
    
    [#v(3.4em)*Глубина 3*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
|:---------------|---------:|----------:|---------:|--------:|
| baseline       | 48.55 ns |  ±0.124 ns | 48.69 ns |    100% |
| ван Лаарховен  | 234.9 ns |  ±4.966 ns | 248.0 ns | +410.8% |
| конструкторы   | 12.16 ns | ±0.0206 ns | 12.19 ns |  -74.9% |
    ]],
    
    [#v(3.4em)*Глубина 5*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :------------- | -------: | ---------: | -------: | ------: |
| baseline       | 63.08 ns |  ±0.130 ns | 63.21 ns |    100% |
| ван Лаарховен  | 375.8 ns |  ±4.935 ns | 408.2 ns | +547.0% |
| конструкторы   | 14.90 ns | ±0.0387 ns | 14.90 ns |  -76.4% |
      ]],
    stroke: (x: 0pt, y: 0pt),
    align: (center, center),
    inset: 5pt,
  ),
  caption: [Тест производительности модели для различных глубин. Структуры определены в отдельных]
)
]

Однако, модель ван Лаарховена все еще обладает проблемами в выражением `Prism` и `Affine`, которые мы оставили в иерархии.

=== Дефорестированная оптика и динамически расшиняемые реестры
Из предыдущих реализаций моделей мы выяснили, что в языке имеются проблемы с инлайнингом замыканий хранящихся в структурах и что язык достаточно неплохо справляется с инлайнингом функций высших порядков. Мы попробуем разработать свою модель "Оптики", полностью описывающую заданный интерфейс и соответсвующую требованиям, указанным нами в начале главы.

```cangjie
let lensAx = createLens(
    view: { source: A => source.x },
    update { source: A, focus: B => A(focus, source.y) } 
)
```
```cangjie
public struct LensReg<T> {}

extend LensReg<A> {
    func xForward(source: A) { source.x }
    func xBackward(source: A, focus: B) { A(focus, source.y) }
}
```
#definition("Дефорестация")[ избавление от промежуточных структур данных в коде ]
==== Блоки расширения
