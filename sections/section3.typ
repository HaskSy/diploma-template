#import "../lib.typ": *

= Реализация в языке Cangjie

В предыдущей главе мы провели анализ предметной области "Оптики", рассмотрев существующий интерфейс, теоретические модели, позволяющие реализовать этот интерфейс и реализации в промышленных языках. Теперь мы готовы к тому, чтобы реализовать "Оптику" в @cangjie, с учетом его особенностей и ограничений.

Были выставлены следующие требования к дизайну и реализации конечного решения:
- Производительность --- низкая стоимость абстракции или отсутствие стоимости в сравнении с кодом, написанным без "Оптики".
- Поддержание внешних зависимостей
- Поддерживать работу с различными уровнями видимости
- Лаконичный интерфейс взаимодействия
- Предоставлять возможность написания пользовательской "Оптики"
- Объект первого класса

#noindent[
В этой главе мы рассмотрим как выглядит конечный дизайн программного интерфейса нашего решения, для какой "Оптики" мы предоставляем сгенерированные декларации, модель "Оптики", которая была разработана для данной работы и, ввиду особенностей разработанной модели, отдельно рассмотрим как происходит вычисление выражения, которое будет писать пользователь.
]
== Дизайн API
В соответствии с задачами, поставленными перед прототипом в первой главе и в соответствии с особенностями языка, иерархия была уменьшена и представлена на @reduced_hierarchy[диаграмме].
#figure(
  image("../attachments/figures/reduced_hierarchy.png", width: 45%),
  caption: [ Иерархия #gls("optics", display: ["Оптики"]) прототипа],
  placement: auto
) <reduced_hierarchy>

Из иерархии (@classic_hierarchy[Рисунок]) были убраны `Fold`, `Getter` и `Traversal`. `Traversal` (вследствии этого `Fold`) был исключен из иерархии в соответствии с соображениями, которые были обсуждены при анализе Kotlin Arrow (@kotlin_arrow[см. раздел]), они столь же применымы и для @cangjie. `Getter` же, был исключен, так как в @cangjie, в отличие от функционального языка, это понятие уже присутствует (в том числе неизменяемые `property`) и подходящих сценариев применения найдено не было.

В качестве выигрыша мы получаем более простую иерархию, в которой любой существующий вид "Оптики" композируется с любым другим видом "Оптики", тем самым избавляя нас от исключителных случаев

Так как язык @cangjie является объектно-ориентированным, то в нем присутствует отношение подтипизации на типах, что в нашем случае означает отсутствие *let-полиморфизма*. В месте применения #gls("optics", display: ["Оптики"]) нам необходимо знать уже все типы `a`, `b`, `s`, `t`, что либо заставит пользователя указывать их вручную, что неудобно. Поэтому, в рамках прототипа, мы ограничимся только реализацией мономорфной "Оптики".

== Генерируемая и предоставляемая "Оптика"
В этом разделе мы определимся с той "Оптикой", которую мы можем автоматически генерировать для пользователя и как будет выглядеть интерфейс для генерации.

#definition("Deriving")[ автоматическая генерация реализаций типовых классов на основе структуры типа. ]
Для кодогенерации на основе структуры типа данных, в @cangjie используется механизм deriving, работающий с помощью процедурных макросов. Данный механизм не является расширяемым для разработчиков за пределами стандартной библиотеки, и используется, для генерации интерфейсов.

В рамках прототипа мы будем пользоваться своим упрощенным механизмом deriving. Это не повлияет на виды оптики, которые мы можем сгенерировать. Механизм может быть заменен на расширяемый `@Derive`, предоставляемый стандартной библиотекой, когда тот будет разработан. 

=== `Lens` для структур и классов
```cangjie
@DeriveOptics
struct/class A {
    public var z: String
    public A(
        public var x: B,
        public let y: String
    ) { }
}
```
#noindent[
Ограничения:
- У структуры/класса должен быть определен первичный конструктор.
- Все переменные в первичном конструкторе должны представлять собой поля. Например, для кода ниже, мы не сможем сгенерировать "Оптику", так как не сможем корректно вызвать конструктор
```cangjie
struct A {
  public A(
    public let x: B, // поле объекта
    test: String     // произвольный аргумент функции
  ) { }
}
```.
- Можем генерировать "Оптику" для `public`/`package-private` изменяемых полей, объявленных, как в первичном конструкторе, так и за его пределами.
- Можем генерировать "Оптику" для `public`/`package-private` неизменяемых полей, объявленных в первичном конструкторе.
- "Оптика" должна быть видна в соответствии с областями видимости полей.
]
=== `Prism` для ADT
#definition("Алгебраический тип данный (ADT)")[ составной тип, состоящий из типов-сумм и типов-произведений ]
#definition("Тип-сумма")[ тип, способный принимать значения нескольких различных типов. ]
#definition("Тип-произведение")[ декартово произведение типов ] // Очень понятно...
```cangjie
@DeriveOptics
enum EnumList<T> {
    | Nil
    | Cons(T, EnumList<T>)
}
```
В данном сценарии мы можем возвращать `Prism` выполняющую сопоставление с образцом и в случае успеха, возвращающую кортеж из всех элементов составляющих объект
#definition("Сопоставление с образцом")[ языковое средство, занимающееся деструктуризация значения, при его соотвестивии опреденным условиям. ]
=== `Lens` для кортежей
Для удобства пользования кортежами, можно предоставить ограниченное количество перегрузок специальных линз `_1`, `_2`, ..., для кортежей различной длины.

Были попытки сделать, гетерогенный список, в который бы транслировались кортежи, для написания одной полиморфной по числу аргументов коржета линзы, однако в @cangjie невозможно выразить числа на уровне типов.

=== `Iso`
```cangjie
@DeriveOptics
public struct/class A {
    public A(
        public let x: String
    ) { }
}

public enum SingleEnum {
    | Value(String)
}
```
`Iso` можно определить для:
- Классов/структур с одним единственным полем, объявленным в первичном конструкторе
- Алгебраических типов данных, с единственным конструктором данных
=== Оптика для стандартной библиотеки
Также, как это сделано в `Scala Monocle` можно предоставлять "Оптику" для типов, определенных в стандартной библиотеке и позволять её импортировать отдельной зависимостью. Однако, разработка полноценного набора "Оптик" для стандартной библиотеки не несет в себе ни научной значимости, ни технической сложности, поэтому находится за пределами данной работы

== Выбор модели
Для продолжения дизайна нашего пользовательского интерфейса, необходимо определиться с моделью "Оптики", так как способ взаимодействия во многом определяется моделью, находящейся за интерфейсом.

В данном разделе мы произведем замеры производительности различных моделей и в конечном итоге разработаем собственную модель, стараясь при этом удовлетворить всем требованиям, поставленным перед библиотекой.
=== `getter`/`setter` модель и её проблемы
Дабы исследовать возможности языка, была написана версия "Оптики", использующая под собой `getter`/`setter` модель и интерфейсы в соответствии с определенной нами иерархией. Ниже приведен пример одного из интерфейсов `Lens<S, A>`, другие интерфейсы реализовывались аналогичным образом (@app:A[см. Приложение]).

```cangjie
sealed interface Lens<S, A> <: Optionals<S, A> {
    prop view: (S) -> A
    prop update: (S, A) -> S
    prop preview: (S) -> Either<S, A> {
        get() { { source: S => Right(view(source)) } }
    }
}

private struct ValueLens<S, A> <: Lens<S, A> {
    ValueLens(
        private let _view: (S) -> A,
        private let _update: (S, A) -> S
    ) { }

    public prop view: (S) -> A {
        get() { _view }
    }

    public prop update: (S, A) -> S {
        get() { _update }
    }
}
```

Композиция выполняется с помощью специальной публичной функции `compose`:
```cangjie

public func compose<S, A, B>(l1: Lens<S, A>, l2: Lens<A, B>): Lens<S, B> {
    ValueLens(
        { source: S => l2.view(l1.view(source)) },
        { source: S, focus: B => l1.update(source, l2.update(l1.view(source), focus)) }
    )
}
```

==== Пример и бенчмаркинг
В качестве простейшего теста производительности для данной и далее описываемых моделей выступает следующая пара структур. Наша задача -- заменить `"Old"` на `"New"`, внутри неизменяемой переменной `bow`. Если результаты на данном тесте нас будут удовлетворять, то будем переходить к более сложным тестам.

#noindent[
```cangjie
public struct A {
    public A(
        public var x: B,
        public var y: String
    ) { }
}

public struct B {
    public B(
        public var x: String,
        public var y: String
    ) { }
}

let bow = A(B("Brave", "Old"), "World")
```

В языке подобное можно сделать достаточно простым кодом, используя @cow семантику, предоставляемую структурами. Либо пересобрать, вызывая конструкторы

```cangjie
var _tmp = bow
_tmp.x.y = "New"
let bnw = _tmp
```

"Оптика", которую нам необходимо сгенерировать для пути `bow.x.y` выглядит следующим образом
```cangjie
public let lensAx = createLens(
    { source: A => source.x },
    { source: A, focus: B => A(focus, source.y) }
)

public let lensBy = createLens(
    { source: B => source.y },
    { source: B, focus: String => A(source.x, focus) }
)
```
Либо, мы можем написать специально для этого пути отдельную "Оптику", которая использует @cow семантику структуры
```cangjie
public let best = createLens(
  { source: A => source.x.y },
  { source: A => focus: String =>
      var tmp = source
      tmp.x.y = focus
      tmp
  }
)
```

В @app:B[приложении] представлен пример теста производительности, написанного с помощью предоставляемого стандартной библиотекой фреймворка.

Результаты данного теста представлены в таблице ниже. Этот и дальнейшие тесты производительности были запущены с параметрами: 1s -- прогрев, 200 -- размер батча, 5s -- выполнение.
#figure(
  three-line-table[
    | Сценарий           |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :----------------- | -------: | ----------: | -------: | ------------: |
    | baseline           | 2.527 ns | ±0.0124 ns  | 2.527 ns |          100% |
    | "Оптика"           | 1489  ns | ±24.6 ns    | 1271  ns |     +50149.7% |
    | update = baseline  | 112.1 ns | ±2.053 ns   | 125.2 ns |      +4852.0% |
  ],
  caption: [ Тест производительность `getter`/`setter` модели ],
)
После дальнейшего анализа assembler для функции `opticsBaseline` было обнаружено большое количество `lea` инструкций, которые, в данном сценарии, используются для подгрузки содержимого из адресов, по которым расположены построенные нами замыкания. Это является индикатором того, что у языка возникли проблемы с инлайнингом вызовов замыканий.
]

Дальнейший анализ для функции `bestOptics`, других примеров и изменение thresholdов инлайнинга в фронтенде компилятора указывает на то, что @cangjie никогда не выполняет инлайнинг для любых замыканий, хранящихся внутри полей структуры.
#figure(
  three-line-table[
    | Сценарий           |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :----------------- | -------: | ----------: | -------: | ------------: |
    | baseline           | 2.529 ns | ±0.0103 ns  | 2.534 ns |          100% |
    | "Оптика"           | 1136  ns | ±9.08 ns    | 1276  ns |     +50356.0% |
    | update = baseline  | 109.2 ns | ±4.660 ns   | 126.5 ns |      +4911.3% |
  ],
  caption: [ Результаты теста производительности после увеличения всех `threshold` в 100 раз. Изменений нет ],
)

На данном этапе возникает выбор между модификацией поведения компилятора и использованием альтернативных моделей "Оптики" с целью оптимизации инлайнинга. Было решено исследовать второй подход, как менее рискованный с точки зрения временных затрат и сложности реализации. Правки в компиляторе могли повлечь за собой каскад "багов", что поставило бы под угрозу своевременное завершение работы. В случае если результаты окажутся неудовлетворительными, предполагается возврат к рассмотрению варианта с модификацией компилятора.

=== модель ван Лаарховена
Как было сказано нами ранее, модель ван Лаарховена инлайнится лучше, чем `getter`/`setter` модель, так как целиком опирается на композицию функций высших порядков. Однако, @cangjie не является чисто функциональным языком, что может привести нас к ограничениям.

Вместо алгебраических типов данных мы будет использовать структуры с generic-параметрами
```cangjie
public struct Const<T, X> {
    public Const(
        public let value: T
    ) { }
}

public struct Identitiy<T> {
    public Identitiy(
        public let value: T
    ) { }
}
```

Классы типов, являются одним из способов реализации ad-hoc полиморфизма. В качестве альтернативы, в языке с этой целью выступает механизм перегрузок функций.
```cangjie

func fmap<X, Y, A>(_: (X) -> Y, a: Const<A, X>): Const<A, Y> {
    Const(a.value)
}
func fmap<A, B>(f: (A) -> B, a: Identitiy<A>): Identitiy<B> {
    Identitiy(f(a.value)}
```

#noindent[
Момент на котором у нас возникает проблема -- необходимость создать оптику. Метод `createLens` имеет следующую сигнатуру:

```haskell createLens :: (s -> a) -> (s -> a -> s) -> (a -> f a) -> s -> f s```
В @cangjie первые два аргумента будут входными агрументами фукнции. В возвращаемом значении возникает неизвестный функтор `f`, который может принимать либо тип `Const<T, X>`, либо тип `Identitiy<T>`. Однако в языке отсутствует higher-kinded полиморфизм и отсутствует перегрузка по возвращаемому значению. Ничего не мешает нам получить функцию ```haskell (a -> f a) -> s -> f s```, однако мы должны заранее знать то, как именно она будет использоваться, для получения значения или для его модификации. Например:
  - разделить фукнцию на две `createLensReader`, `createLensWriter`
  - дополнительный парамерт, определяющий тип функтора `f`.
Это лишает нас возможности использования эту модель "Оптики", как объект первого класса.
==== Тест производительности
#figure(
  three-line-table[
    | Сценарий                                     |  Медиана | Погрешность |  Среднее | Отн. baseline |
    | :------------------------------------------- | -------: | ----------: | -------: | ------------: |
    | `source.x.y = focus`                         | 2.685 ns | ±0.552 ns   | 3.004 ns |          100% |
    | модель ван Лаарховена                        | 86.83 ns | ±1.764 ns   | 87.29 ns |      +3151.3% |
    | модель `getter`/`setter` (update = baseline) | 140.0 ns | ±3.987 ns   | 141.1 ns |      +5154.8% | ],
  caption: [ Результаты теста производительности для модели ван Лаарховена ],
)
]
Значительное улучшение, в сравнении с предыдущей моделью. "Оптика" из текущей модели, построенная через композицию функций, которые можно генерировать независимо друг от друга работает быстрее, чем специально написанная под тест "Оптика" на основе предыдущей модели.

#noindent[
Проведем дополнительную серию тестов производительности, где мы генерируем структуры различной глубины вида:
```
let bow = A0(A1(...(An_1(An("Brave", "Old"), "World"), ...), "World"), "World")
```
Задача прежняя --- заменить "Old" на "New". Был проведен тест, замеряющий результаты вплоть до глубины вложености 15, однако рассмотрим только глубины 2,3 и 5. (@bench_laarhoven_same[Таблица])

#figure(
  table(
    columns: 2,
    [#v(3.4em)*Глубина 2*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :--------------| -------: | ---------: | -------: | ------: |
| baseline       | 2.616 ns |  ±0.250 ns | 3.068 ns |    100% |
| ван Лаарховен  | 8.553 ns |  ±0.151 ns | 8.329 ns | +218.4% |
| конструкторы   | 2.684 ns | ±0.025 ns | 2.728 ns |   +4.3% |
      ]],
    
    [#v(3.4em)*Глубина 3*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
|:---------------|---------:|----------:|---------:|--------:|
| baseline       | 63.95 ns | ±1.854 ns | 65.54 ns |    100% |
| ван Лаарховен  | 134.2 ns | ±7.874 ns | 142.2 ns | +122.3% |
| конструкторы | 13.14 ns | ±0.412 ns | 12.61 ns |  -80.3% |
    ]],
    
    [#v(3.4em)*Глубина 5*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :------------- | -------: | ---------: | -------: | ------: |
| baseline       | 65.21 ns |  ±0.718 ns | 65.12 ns |    100% |
| ван Лаарховен  | 534 ns   | ±15.8 ns | 518 ns   | +694.0% |
| конструкторы   | 15.55 ns |  ±0.775 ns | 15.49 ns |  -76.2% |
      ]],
    stroke: (x: 0pt, y: 0pt),
    align: (center, center),
    inset: 5pt,
  ),
  caption: [Тест производительности модели для различных глубин. Структуры и работа с ними происходят в одном пакете]
) <bench_laarhoven_same>
@cow семантика для данного конкретного примера оказывается медленнее, чем вызов конструкторов вручную. Несмотря на то, что все типы данных (`String`) неизменяемые. Это, определенно, баг в языке, и не связан напрямую с "Оптикой", однако, это также означает, что если нам удастся заинлайнить и проредуцировать "Оптику" до того же кода, что и вызов конструкторов, то "Оптика", может быть потенциально быстрее чем @cow. Причем, вне зависимости от места определения структур (@bench_laarhoven_separate[Таблица])
#figure(
  table(
    columns: 2,
    [#v(3.4em)*Глубина 2*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :--------------| -------: | ---------: | -------: | ------: |
| baseline       | 2.535 ns | ±0.00750 ns | 2.544 ns |     100% |
| ван Лаарховен  | 83.21 ns |   ±1.672 ns | 87.65 ns | +3358.0% |
| конструкторы   | 2.534 ns |  ±0.0104 ns | 2.544 ns |    +0.4% |
      ]],
    
    [#v(3.4em)*Глубина 3*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
|:---------------|---------:|----------:|---------:|--------:|
| baseline       | 48.55 ns |  ±0.124 ns | 48.69 ns |    100% |
| ван Лаарховен  | 234.9 ns |  ±4.966 ns | 248.0 ns | +410.8% |
| конструкторы   | 12.16 ns | ±0.0206 ns | 12.19 ns |  -74.9% |
    ]],
    
    [#v(3.4em)*Глубина 5*], [#three-line-table[
| Сценарий       |  Медиана | Погр. |  Среднее | Отн. base. |
| :------------- | -------: | ---------: | -------: | ------: |
| baseline       | 63.08 ns |  ±0.130 ns | 63.21 ns |    100% |
| ван Лаарховен  | 375.8 ns |  ±4.935 ns | 408.2 ns | +547.0% |
| конструкторы   | 14.90 ns | ±0.0387 ns | 14.90 ns |  -76.4% |
      ]],
    stroke: (x: 0pt, y: 0pt),
    align: (center, center),
    inset: 5pt,
  ),
  caption: [Тест производительности модели для различных глубин. Структуры определены в отдельных],
  // placement: auto
) <bench_laarhoven_separate>
]

#noindent[Однако, модель ван Лаарховена все еще обладает проблемами с выражением `Prism` и `Affine`, которые мы оставили в иерархии.]

=== Дефорестированная оптика и оптические реестры
Из предыдущих реализаций моделей мы выяснили, что в языке имеются проблемы с инлайнингом замыканий хранящихся в структурах и что язык достаточно неплохо справляется с инлайнингом функций высших порядков. Мы попробуем разработать свою модель "Оптики", полностью описывающую заданный интерфейс и соответсвующую требованиям, указанным нами в начале главы.

#noindent[
Так как основная проблема -- в промежуточных структурах, хранящих `getter`/`setter` то будем пытаться максимально от них избавиться. Данный процесс называется *дефорестацией*
#definition("Дефорестация")[ избавление от промежуточных структур данных в коде @wadler ]

Процесс дефорестации является компиляторной оптимизацией в функциональных языках программирования. @shortcut_deforestation Однако реализация данной оптимизации с нуля в frontend компилятора, является сложной задачей и выходит за рамки данной работы. Предложение -- хранить "Оптику" в уже дефорестированном виде, как одна/две функции. Единственными способами хранения "Оптики" без промежуточных структур являются:
#enum(
[Функции на верхнем уровне],
[Переменные на верхнем уровне хранящие замыкание],
[Статические переменные в области имен объектов, хранящие замыкание],
[Методы объекта и статические функции в их области имен],
)
Первые два варианта не расматриваются по причине того, что они "засоряют" глобальную область имен. Четверный вариант в сущности сводится к третьему (любую функцию/метод можно использовать как замыкание или "обернуть"), поэтому мы будем пытаться закодировать дефорестированную "Оптику" с помощью методов и статических функций, привязанных к объектам. Добавление методов/функций в область имен достигается за счет блоков-расширений
]

==== Блоки расширения
Мы можем переписать "Оптику" через блоки-расширения, например следующим образом
#figure(
  table(
    columns: 2,
    [#v(3.4em)*До:*], [
```cangjie
let lensAx = LensObject(
    { source: A => source.x },
    { source: A, focus: B =>
        A(focus, source.y)
    } 
)
```],
    
    [#v(3.4em)*После:*], [
```cangjie
extend A {
    public static func xView(source: A) { source.x }
    public static func xUpdate(source: A, focus: B) { 
        A(focus, source.y)
    }
}
```
    ],
    
    stroke: (x: 0pt, y: 0pt),
    align: (center, center),
    inset: 5pt,
  ),
  // caption: [Тест производительности модели для различных глубин. Структуры определены в отдельных],
  // placement: auto
) 
#noindent[
Этот способ не является оптимальным, так как "засоряет" область имени объекта и не исключает ошибок с существованием данных фукнций, когда мы начнем их генерировать. Вместо этого введем понятие *оптического реестра*


#definition("Оптический реестр")[Специальная, предоставленная библиотекой структура с полиморфным типом `LensReg<T>` хранящая все "Оптики" соответствующего ей вида определенные для типа `T`]

Перепишем тот пример, что был ранее на пример с реестром:
```cangjie
public struct LensReg<T> { }

extend LensReg<A> {
    public static func xView(source: A) { source.x }
    public static func xUpdate(source: A, focus: B) { 
        A(focus, source.y)
    }
}
```
Так как "Оптика" была `Lens`, то используем соответствующий реестр `LensReg`. Так как тип переменной `source` равен `A`, то тип расширяемой структуры `LensReg<A>`. Аналогичные реестры существуют для всех видов "Оптики": `IsoReg`, `LensReg`, `PrismReg`, `AffineReg`, `SetterReg`.

Вспомним, что у нас есть различные уровни видимости, мы бы хотели это отразить как-то в соответствии с нашей модели
==== Уровни видимости
Обратимся к некоторым правилам экспортирования блоков-расширений, описанных в спецификации языка. Нас интересует только два:

#block[
*Правило 1* --- `extend SomeT` объявленный в пакете, отличном от пакета объявления типа `SomeT`, не эскпортируется
]
#block[
*Правило 2* --- `extend SomeT<OtherT> <: Interface<OtherT>` экспортируется, если в месте видны и `SomeT` и `Interface` и `OtherT`
]

Таким образом экспорт нашей "Оптики" ограничен видимостью типа `T` указанного в реестре. И мы можем разделять `package-private` и `public` "Оптику" за счет генерации соответствующего интерфейса в месте определения.

```cangjie
public struct Test {
    Test(
        public let x: String, // Публичная "Оптика"
        let y: String // В рамках пакета
    ) { }
}

// Видна только в рамках пакета
extend LensReg<Test> {
    public static func yView(source: Test) { ... }
    public static func yUpdate(source: Test ,focus: String) { ... }
}

// Будет экспортироваться за пределы пакета
sealed interface TestOpticsImpl {
    public static func xView(source: Test) { ... }
    public static func xUpdate(source: Test, focus: String) { ... }
}
extend LensReg<Test> <: TestOpticsImpl { }
```
У данного решения есть проблема с "засорением" глобальной области видимости генерирующимися интерфейсами, заставляя пользователя использовать импорты символов через синтаксис `import package.*`. Однако проблема гигиены макросов в @cangjie существует как явление, и её решение находится далеко за пределами данной работы.

Использование блоков-расширений позволит нам достичь следующего:
- Дефорестация с целью улучшения инлайнинга (@chapter4[см. главу])
- Отделение методов "Оптики" от методов объекта -- позволяет потенциально предоставлять "Оптику" отдельной зависимостью
- Экспорт "Оптики" согласован с областями видимости

Однако, есть проблема, усложняющая работу с данной моделью: так как параметрический полиморфизм в @cangjie не является инстанциирующим, то все функции/методы, которые мы будет добавлять с помощью блоков-расшинений -- лежат в одной области имен. Из этого следует, что "Оптики" с одинаковыми именами, как например те, что мы генерируем для модификации полей, должны иметь разные сигнатуры методов. Это можно обойти, добавляя в качестве аргумента функций тип `Phantom<T>` для достижения однозначности разрешения имен, но является крайне неудобным.
]

== Написание DSL с помощью макросов
Модель, которую мы, в конечном итоге, разработали, является крайне неудобной для использования сама по себе. Чтобы это исправить, мы воспользуемся имеющимися средствами языка и разработаем @dsl на процедурных макросах
=== DSL и семантика
Мы попытаемся максимально имитировать синтаксис через точку, для удобства пользователя. Для конечного решения, типичное использование "Оптики" выглядит следующим образом:
#noindent[
```cangjie

@Optics(value.x.coerce<String>().at(3).@Ref(opticVar) = "3")
```
Для начала опишем все макросы, которые могут быть использованы в данном @dsl, затем разберем данное выражение.
]
#definition("Функция интерпретации (eval)")[ функция, выполняющая вычисление или интерпретацию абстрактного синтаксического дерева. ]
- `@Optics` --- По сути своей, представляет собой функция интерпретации (`eval`) нашего @dsl. Транслирует написанное в нем выражение, в код на @cangjie
- `@TypeOf(value)` --- Извлекает тип объекта, переданного в качестве аргумента. Предоставляет доступ к "Оптике", определенной для типа значения `value`. Только первый аргумент может быть обернут в этот макрос.
- `@Type(type)` --- Интерпретирует переданный аргумент `type`, как типовой параметр. Предоставляет доступ к "Оптике", определенной для данного типа `type`. Только первый аргумент может быть обернут в этот макрос.
- `@Ref(value)` --- Интерптерирует переданный аргумент `value`, как "Оптику", хранящуюся внутри структуры. Нужно для возможности работы с "Оптикой", как с объектом первого класса. Сильно замедляет исполнение

Теперь мы можем разобрать выражение:
- `value` --- первый элемент в цепочке. Если первый он обернут в макрос `@Type/@TypeOf`, то результатом выражения будет объект первого класса, который надо вызвать. В данном контектсе, он не обернут, поэтому интерпретируется как аргумент функции `getter` или `setter`.
- `.` --- Оператор композиции, подробнее о принципе его работы в следующем разделе
- `coerce<String>()`, `at(3)`, `@Ref(opticVar)` --- Различные объекты "Оптики"
- `= "3"` --- Всегда последний элемент в выражении, интерпретируется, как аргумент, передаваемый в `setter`

Таким образом можно выделить 4 синтаксиса, которые интерпретируются в различные "Оптики":
- `let s = @Optics(value.x.charAt(0) = "b")` --- Подставляет значение, и возвращает обновленную структуру
- `let a = @Optics(value.x.charAt(0))` --- Достает значение, на которое сфокусирована "Оптика"
- `let obj = @Optics(@TypeOf(value).x.charAt(0))` --- "Оптика" `obj`. Можно потом обратиться к ней через `@Ref`
- `let setter = @Optics(@Ref(obj) = "b")` --- "Оптика" `setter`. Можно только модифицировать значение

=== Композиция через CPS
#definition("Левоассоциативность")[ правило группировки операторов, при котором операции выполняются слева направо (например, `a - b - c` -> `((a - b) - c)`. ]
Оператор композиции является левоассоциативным. Синтаксис организован таким образом, чтобы можно было однозначно определить, является ли "Оптика" сгенерированной нами, определенной пользователем или специальным случаем. Определяется с помощью следующего типа суммы:
```cangjie
enum CompositionNode {
    | Derived(Token)
    | Type(RefExpr)
    | TypeOf(Tokens)
    | Ref(Token)
    | Coerce(TypeNode)
    | UserDefined(CallExpr)
}
```
Возвращаясь к предыдущему примеру
```cangjie

@Optics(value.x.coerce<String>().at(3).@Ref(opticVar) = "3")
```
- `CompositionNode.Type` --- Встретили макрос `@Type`
- `CompositionNode.TypeOf` --- Встретили макрос `@TypeOf`
- `CompositionNode.Ref` --- Встретили макрос `@Ref`. (В примере: `@Ref(opticVar)`)
- `CompositionNode.Coerce` --- Встретили выражение `coerce<T>()`. Является идентификатором того, вид оптики - `Iso` (В примере: `coerce<String>()`)
- `CompositionNode.Derived` --- Встретили идентификатор поля или имя конструктора данных. Записываются одним словом (В примере: `x`)
- `CompositionNode.UserDefined` --- Встретили `callExpr`. Через них определяется пользовательская "Оптика" и "Оптика" предоставленная нами, но не сгенерированная (В примере: `at(3)`)

Генерация происходит с помощью следующего CPS @tardis:
#align(center)[
    #block[#align(left)[
        ```haskell CtxVars -> (CtxVars -> (Tokens, UsedVars)) -> (Tokens, UsedVars)```
    ]]
]

Каждая строчка генерируемого кода записывается в виде `let varName = expr`. В качестве выражений `expr` может выступать:
- Объект оптического реестра с указанным/выведенным типом
- Вспомогательный объект для разрешения имен "Оптики" (@name_resolution[см. в разделе])
- `getter`, как часть дефорестированной композиции "Оптик", записанный в переменную для дальнейшего использования
- `setter`, как часть дефорестированной композиции "Оптик", записанный в переменную для дальнейшего использования

CPS используется для получения списка использованных с текущего шага переменных. Если `UsedVars` не содержит `varName`, то все выражение `let varName = expr` удаляется из списка на генерацию. Например, для композиции "Оптики" с целью вызова `get` ничего не нужно, кроме `get` с каждого из шагов. `setter`ы можно не генерировать Это упрощает сгенерированный код и избавляет пользователя от предупреждений о неиспользуемых переменных.

CPS принимает на вход переменные с предыдущего шага, что позволяет нам удобно использовать результаты с предыдущих шагов через обращение по именам переменных.
- Если необходимо вернуть объект первого класса, хранящий `getter` и `setter`, то просто читаем из их переменных
- Если необходимо выполнить композицию с предыдущим шагом, делаем её в дефорестированном виде
- Если "Оптика" с предыдущего шага была прочитана из объекта, а не из реестра, то нам это неважно, они уже разложены по переменным.
- и т. д.

В @app:D[приложении] представлен пример выражения, и сгенерированного из него @cangjie кода.

Однако процедурные макросы в @cangjie на данный момент, не имеют доступа к типовой информации выражений, с которыми они работают. Необходимо доработать механизм для получения типобезопасного DSL
=== Типобезопасность DSL и разрешение имен <name_resolution>
Из отсутствия типовой информации на моменте кодогенерации возникает несколько проблем:
#enum(
[Мы не знаем, какой объект "Оптики" возвращается в выражении],
[Мы не знаем, какие методы есть у объекта],
[Одним из ограничений языка является запрет на вызов статических функций у объектов]
)

Третья проблема решается просто --- генерируем в блоках-расширениях методы вместо статических функций. В некоторых случаях создаем лишние объекты, однако они, скорее всего, будут соптимизированы.

#noindent[
Для решения двух других проблем нужно завести некую конвенцию, по которой будет генерироваться код и как он будет доставать информацию.

Заведем специальный объект `OpticsResolver<T>`, хранящий в себе 2 типа методов:
- Методы, возвращающие оптический реестр, соответствующий виду объекта "Оптики" `x<T, U>`, определенной над типом `T` --- используется, чтобы достать дефорестированную "Оптику" `x`
- Метод, возвращающий `OpticsResolver<U>`, соответсвующий объекту "Оптики" `x<T, U>`, определенной над типом `T` --- используется, чтобы получить доступ к "Оптике", которой можно продолжить цепочку

```cangjie
extend OpticsResolver<A> {
    public func xOptics(_: Phantom<A>): OpticsResolver<B> {
        OpticsResolver()
    }
    public func yOptics(_: Phantom<A>): OpticsResolver<String> {
        OpticsResolver()
    }
    public func downcast(_: Phantom<A>): LensReg<A> {
        LensReg()
    }
}
```
]

Благодаря тому, что у нас закрытая иерархия --- мы можем решить проблему работы с неизвестными типами с помощью перегрузок и осмысленных наименований фунцкий:
#definition("Свидетель типа")[ это значение, которое явно или неявно подтверждает (доказывает) наличие определённого свойства у типа во время компиляции. Например: `Phantom` из языка `rust`]
- `composeForward` --- перегрузки для построения `getter` функции. Сигнатуры отличаются только в типе оптических реестров, выступающих, как свидели типа.
```cangjie composeForward<S, A, B>(_: LensReg<S>, _: LensReg<A>):
        ((S) -> A, (A) -> B) -> (S) -> B```
- `composeBackward` --- перегрузки для построения `setter` функции. Сигнатуры отличаются только в типе оптических реестров, выступающих, как свидели типа.
```cangjie composeBackward<S, A, B>(_: LensReg<S>, _: LensReg<A>):
        ((S) -> A, (S, A) -> S, (A, B) -> A, (A) -> B) -> (S, B) -> S```
- Функции для получения объекта для разрешения имен и оптических реестров
```cangjie

firstClassToWitness<S, A>(_: Lens<S, A>): LensReg<S>
firstClassNext<S, A>(_: Lens<S, A>): OpticsReg<A>
firstClassForward<S, A>(_ Lens<S, A>): (S) -> A
firstClassBackward<S, A>(_ Setter<S, A>): ((A) -> A, S )-> S
```

В следующей главе мы проведем тест производительности конечного решения и демонстрацию на различных примерах
