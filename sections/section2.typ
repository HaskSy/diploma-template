#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением сформулированных нами задач. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будут рассмотрены: @optics, как модель; реализации в функциональных языках программирования; а также существующие реализации в языках программирования с иной парадигмой. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков в @cangjie.
== Формальное описание "Оптики"
#definition(["Фокус"])[  выделенный элемент структуры данных, например, результат функции get. ]

@optics может быть представлена, как интерфейс из одной/двух функций, взаимодействующих друг с другом по определенным правилам. Одна описывает -- как извлечь данные из структуры. Другая -- как заменить данные, извлеченные первой функцией на их модифицированную версию. Учитывая разнородность данных, с которыми может взаимодействовать разработчик, естественно предположить существование различных *видов "Оптики"*, специализирующихся на конкретных видах данных. Каждый вид "Оптики" может быть задан полиморфным типом следующего вида: 

#definition([Вид "Оптики"])[ классификация "Оптики" по их структуре и способу взаимодействия с данными. ]
#noindent[
#align(center)[
`type Optic id a b s t`
#align(left)[где: #list(
  [`id` --- Идентификатор вида "Оптики"],
  [`s`  --- Тип стуркуты],
  [`a`  --- Тип значения лежащего в структуре],
  [`b`  --- Тип модифицированного значения],
  [`t`  --- Тип структуры, хранащей модифицированное значение],
  marker: [-]
)]
]]

Частным случаем #gls("optics", display: ["Оптики"]) является *мономорфная "Оптика"*.
#definition([Мономорфная "Оптика"])[Объект "Оптики", который не меняет типы значения и обрамляющей её структуры. То есть `s` = `t` и `a` = `b`]

=== Виды "Оптики"
Рассмотрим несколько классических видов #gls("optics", display: ["Оптики"]), чтобы понять принцип их разбиения. Для простоты, все дальнейшее обсуждение будет в контексте мономорфной "Оптики". Чтобы перейти к сигнатурам методов для полиморфной оптики нужно:
#list(
    [Заменить тип `s` на тип `t` в ковариантных позициях],
    [Заменить тип `a` на тип `b` в контрaвариантных позициях]
)
// #definition("Ковариантная позиция типа")[ возвращающей позиции функции (положительная позиция) ]
// #definition("Контрвариантная позиция типа")[ принимающая позиция функции (отрицательная позиция) ]

==== Изоморфизм (Iso)
Самый простой из всех видов "Оптики". Как следует из названия, существование объекта такого вида, утверждает, что типы `s` и `a` хранят под собой одну и ту же информацию, но предствленную в различном виде. *Iso* описывает то, как перейти из одного представления в другое и обратно. Интерефейс состоит из следующих двух функций:
#noindent[
#align(center)[
    #block[#align(left)[
    `to :: s -> a`

    `from :: a -> s`
    ]]
]
]
==== Линза (Lens)
Пожалуй, самый распространенный из всех видов "Оптики". Пусть `s` -- тип-произведение, тогда тип `a` -- одна из составных частей этого типа. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `view :: s -> a`

    `update :: (s, a) -> s`
    ]]
]
Сигнатура и поведение методов очевидно. Достаем часть `a` структуры `s` через метод `view`, Заменяем часть `a` переданной на вход структуры `s` на имеющуюсяя часть `a` с помощью метода `update`.
]
==== Призма (Prism)
Пусть `s` -- тип-сумма, тогда тип `a` -- один из возможных типов, который может скрываться за типом `s`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `build :: a -> s`
    ]]
]
]
==== Affine
Комбинация двух предыдущих видов "Оптики". Пусть `s` -- тип-сумма типов-произведений, тогда тип `a` составная часть некоторых из типов-произведений. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `update :: (s, a) -> s`
    ]]
]

Стоит заметить, что здесь, несмотря на то, что сигнатура метода `update` выглядит также, его семантика изменилась в сравнении с линзой. Метод `update` у линзы всегда проходил успешно и модифицировал структуру данных. Здесь же, сначала идет проверка, что переданный аргумент типа `s` действительно имеет `a`, как свою составную часть. И если это так, то происходит замена на новое значение типа `a`, иначе -- возвращаем `s` без изменений
]
==== Traversal
Расширение предыдущей "Оптики". Affine можно альтернативно интерпретировать, как то, что в нашем объекте `s` хранится либо 0 либо 1 экземпляр типа `a`. Тогда Traversal говорит нам, что объект `s` может хранить в себе произвольное количество экземпляров типа `a`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `toList :: s -> [a]`

    `over :: (a -> a) -> s -> s`
    ]]
]
Объект описывает способ достижения и порядок обхода всех экземпляров типа `a`, которые можно извлечь из объекта `s`.
]
==== Setter
Отдельный вид "Оптики". В отличие от всех описанных ранее видов, определяется одним единственным методом `over`:
#noindent[
#align(center)[
    #block[#align(left)[
    `over :: (a -> a) -> s -> s`
    ]]
]
Фокусируется на произвольные значения типа `a`, хранимые в структуре, позволяя нам, перед этим, добавить свое преобразование `a -> a`.
]

=== Иерархия "Оптики", законы и композиция
// Описанный нами выше набор "Оптик" не является полным, однако, демонстрирует в достаточной мере суть абстракции. Ранее, мы выделили 3 основных свойства "Оптики", которые мы считаем важными: Персистентный интерфейс, композируемость и объект первого класса. Формально это достигается через другие свойства "Оптики", которые мы рассмотрим.
Можно заметить, что различные оптики, перекрывают своей функциональностью друг друга. Так, например, очевидно, что `Lens` это `Affine`, который всегда сфокусирован на одном значении. Или, например, `Setter` -- самая общая и гибкая "Оптика", позволяющая модифицировать данные. Ниже приведена диаграмма, отображающая иерархию наследования между видами "Оптики".

#figure(
  image("../attachments/figures/hierarchy.png", width: 45%),
  caption: [ Диаграмма иерархии #gls("optics", display: ["Оптики"])]
) <classic_hierarchy>
#noindent[
Приведенная иерархия не является полной и может быть расширена @bigger_hierarchy. Хотя `Setter` достаточно для всех задач, использование более специализированных "Оптик" дает преимущество наличия различных типовых гарантий. Эти типовые гарантии выражаются в виде существования значений для извлечения, их количества и так называемых *законов "Оптики"*:
#definition([Законы "Оптики"])[ набор правил, которым должны удовлетворять корректные "Оптики" для достижения отсутствия эффектов и предсказуемого поведения. ]
Пример законов для линзы:
  #align(center)[
    #block[#align(left)[
      #enum(
        [`set l (get l s) s = s`],
        [`get l (set l a s) = a`],
        [`set l a' (set l a s) = set l a' s`],
      )
    ]]
  ]
  Полный набор законов, для всех видов "Оптики" описан в реализациях различных библиотек @haskell_lib. Законы позволяют интерпретировать поведение оптики логичным и ожидаемым образом, предотвращают ошибки, которые могут быть связаны, например, с утратой данных, а также соблюдение законов позволяет производить оптимизации для предотвращения лишних вычислений. "Оптику", удовлетворяющую своим законам, мы будем называть *семантически корректной*.
]

#definition([Семантически корректная "Оптикa"])["Оптика", удовлетворяющая законам соответствующим своему виду.]

  
"Оптика", по своему определению -- композируема. Обычно это делается путем предоставления специальной функции `compose`:
#noindent[
#align(center)[
    #block[#align(left)[
            ```haskell

            class Compose id1 id2 id3 | id1 id2 -> id3 where
              compose :: Optic id1 u s -> Optic id2 a u -> Optic id3 a s
            ```
    ]]
]
Композируя различные виды "Оптики", мы получаем новый объект, вид которого однозначно определяется видами композируемых "Оптик", а именно, наименьший общий предок в иерархии. Например: композиция Lens и Prism возвращает нам Affine. В исключительных случаях "Оптики" не могут быть скомпозированы друг с другом, так как находятся в разных частях иерархии и не имеют общих предков. Например: `Getter` и `Setter`.
]
Также, важным свойством композиции является сохранение семантической корректности. Если оба объекта "Оптики" были построены сематнически корректно, то и результат их композиции останется семантически корректной. 
=== Модели "Оптики"
#definition([Модель "Оптики"])[ это конкретный способ кодирования "Оптики" в виде структуры данных или функции, который реализует её формальную модель (законы, операции, композицию) ]
#definition("Тип-запись")[ составной тип данных, содержащий именованные поля (например, структуры или кортежи с именованными элементами). ]

Существует множество моделей, с помощью которых можно реализовать описанный нами выше интерфейс и его поведение. Самая очевидная из них -- пара `getter`/`setter` функций, хранящихся в типе-записи, в точности отражающей API "Оптики".

Существует множество других реализаций, однако они требуют достаточно продвинутых возможностей от языка, таких как: Экзистенциальные типы, Higher-kinded полиморфизм, классы типов
==== Экзистенциальная модель
```haskell

type Optic a s = exists c. (s -> (c, a), (c, a) -> s)
```
Наиболее наглядная из всех моделей. Идея заключается в разбиении структуры данных на две части: Часть на которую объект "сфокусирован" и некий объект типа `c`, с помощью которого мы можем собрать новый объект с только измененной частью `a`.

Модель, в неком смысле является обобщением упомянутой выше `getter`/`setter` модели. Ведь действительно, в случае `Lens`, один из вариантов --- тип `c` равен типу `s` 

```haskell

type Lens a s = (s -> (s, a), (s, a) -> s)
```

Однако, заметных преимуществ у данной модели, в сравнении с предыдущей нет. Фукнции также упаковываются в структуру, а ассоциативные типы (частный случай экзистенциальных типов), на данный момент, в @cangjie не поддерживаются.
==== Модель ван Лаарховена
#definition("Функтор")[контейнер, который можно преобразовать, применяя функцию к его содержимому. (тип, поддерживающий операцию `map`)]
Альтернативный подход, идея которого заключается в определении "Оптики" через ограничения на функтор. И выбор одной из двух функций, на основе функтора удовлетворяющего ограничению. @cps_refs
```haskell

type Optic a s = forall f. Functor f => (a -> f a) -> (s -> f s)
```
#definition("Инлайнинг")[ оптимизация, при которой вызов функции заменяется её телом. ]
Одним из основных преимуществ является упрощение инлайнинга за счет того, что композиция "Оптики" эквивалентна композиции функций высших порядков, вместо построения новых типов-записей на основе других типов-записей.

Для реализации, языку требуется наличие Higher-kinded полиморфизма или его имитация. Для работы с оптикой, как с объектом первого класса нужен *let-полиморфизм*.
#noindent[
#definition("let-полиморфизм")[ возможность локально связанных переменных автоматически обретать полимофные типы, позволяя одному определению специализироваться под разные контексты использования в своей области видимости.]
Иерархия строится с помощью пересечения/объединения ограничений на классы типов функтора.
]
```haskell
type Lens s a = forall f. Functor f => (a -> f a) -> s -> f s

-- Пример линзы для первого элемента пары
_1 :: Lens (a, b) a
_1 f (x, y) = fmap (\x' -> (x', y)) (f x)

main :: IO ()
main = do
    let optic = _1  -- Один объект оптики
    
    -- Специализация под Const (получение значения)
    let getter = optic (Const . id) ("hello", 42)
    let extracted = getConst getter  -- "hello"
    
    -- Специализация под Identity (изменение значения)
    let setter = optic (Identity . const "world") ("hello", 42)
    let modified = runIdentity setter  -- ("world", 42)
```

Однако, существует проблема относительно выразимости "Оптики", оперирующей типами-суммами (такими, как `Affine` и `Prism`) с возможностью их композиромостью. Библиотеки, основанные на данной модели "Оптики" обходят эту проблему путем реализации соответствующих видов "Оптики" через профункторы. @kmett_prism 
==== Модель профункторов (Profunctor Optics)
Обобщение модели ван Лаарховена, с целью решить проблему выразимости "Оптики", оперирующей типами-суммами. Основная идея заключается в замене функциональной стрелки, на её обобщение - профунктор:
```haskell

type Optic a s = forall p. Profunctor p => p a a -> p s s
```

Реализация, также, как и в случае с van Laarhoven, требует от языка наличия Higher-kinded полиморфизма, глобального вывода типов и классов типов.
#definition("Класс типов")[Средство ad-hoc полиморфизма, позволяющее определять несколько одноименных функций в одной области видимости, с четкой, общей сигнатурой]
#definition("Перегрузка")[Средство ad-hoc полиморфизма, позволяющее определять несколько одноименных функций в одной области видимости, с произвольными сигнатурами]
#definition("ad-hoc полиморфизм")[ способность исполнять различный код, оперирующий различными типами, используя один и тот же интерфейс ]

Так как набор требований к возможностям языка, у модели ван Лаарховена и модели профункторов совпадает, то мы не будем останавливаться на ней в деталях. Если сможем реализовать предыдущую модель, то сможем реализовать и модель профункторов. Детальная реализация на haskell описывается в соответствующих статьях. @modular_acc
=== Оптика в объектно-ориентированных языках
Все существующие реализации "Оптики" в языках, в той или иной мере ориентируются на описанные выше модели:
- Модель `getter`/`setter` --- самая распространенная и некоторые примеры мы рассмотрим детальнее.
- Модель ван Лаарховена используется как основа для библиотеки lens в Haskell @kmett_lib
- Модель профункторов можно увидеть в библиотеках Optics @haskell_lib и Fresnel @fresnel_lib

Однако имеет смысл рассмотреть не только абстрактные модели и их реализации в функциональных языках, но и существующие реализации в других языках программирования, в надежде перенести их с наименьшей затратой усилий.

Среди промышленных языков, одними из самых популярных реализации "Оптики", можно назвать библиотеки для Kotlin и Scala. а также Swift KeyPath --- функциональность языка, являющаяся реализацией `Lens`/`Affine` встроенной напрямую в синтаксис и систему типов.
==== Kotlin Arrow <kotlin_arrow>
В Kotlin Arrow @karrow_mainpage качестве модели "Оптики" используется `getter`/`setter` пара фукнций. Персистентность достигается с помощью функции `copy`,  для клонирования объекта, генерируемой компилятором для `data class` сущностей. В @cangjie подобного метода не предоставлено.

Для генерации "Оптики" для пользовательских структур данных используются компиляторные плагины и Reflection API. Заместо плагинов компилятора, @cangjie предоставляет процедурные макросы, а библиотека для рефлексии, на данный момент слабо развита.

Kotlin Arrow поддерживает всю классическую иерархию, переняв её из функциональных языков программирования. Однако, учитывая особенности языка, можно сказать, что в иерархии Kotlin Arrow присутствует лишний элемент иерархии виде `Traversal`. Ввиду отсутствия *Higher-kinded полиморфизма* в языке Kotlin, в нем также отсутствует понятие *аппликативного функтора*.
#definition("Higher-kinded полиморфизм")[ способность абстрагироваться по контейнеру типа (например, `F[String]` в Scala). ]
#definition("Аппликативный функтор")[ это интерфейс для объединения нескольких контейнеров в один, вычисления выполняются в строгой последовательности, но без возможности использовать результат предыдущего шага в следующем. ]

В нашем контексте аппликативный функтор является интерфейсом для объединения двух контейнеров одного типа (Например: конкатенация массивов). Существование ограничения `Applicative` освобождает от необходимости описывать процесс сборки контейнера.
В Kotlin Arrow же для реализаций `Traversal` для объектов стандартной библиотеки это описано вручную @karrow_traversal, что ничем не отличается от `Setter`.
==== Scala Monocle
Scala Monocle @monocle во многом похожая на библиотеку для Kotlin, но имеет несколько преимуществ. Имеет ту же самую иерархию, что и Kotlin Arrow, однако способна использовать это преимущество за счет существования Higher-kinded полиморфизма в языке.

Библиотека предоставляет готовые реализации оптик для большинства структур стандартной библиотеки Scala, включая `List`, `Option`, `Either`, кортежи и др. Например, композиция линз для доступа к элементам вложенного `Option[List[Map[Int, String]]]` может быть выражена единым конвейером. Это избавляет разработчиков от ручного описания обходов для базовых типов.
=== Swift KeyPath
Функциональность языка, пережившая несколько итераций, перед тем, как стать чем-то похожим на "Оптику". Изначально представляла собой специальный строковый литерал, который во время компиляции проверял существование указанных полей в обращаемой структуре. @kp1
```swift

let chris = Person(firstName: "Chris", lastName: "Lattner")
#keyPath(Person.firstName) // => "firstName"
chris.valueForKey(#keyPath(Person.firstName)) // => Chris
```
Во второй итерации была введены несколько видов KeyPath, различающихся в своих типовых гарантиях и специальное выражение вида: `\Type.chain.of.accessors`. @kp2
- *Unknown Path/Unknown Root Type* --- Введен для обратной совместимости с ObjectiveC, который не хранит никакой информации о корректности пути. Проходит компиляцию всегда
- *Unknown Path/Known Root Type* --- Проходит компиляцию, если оперируем над объектом нужного типа, вне зависимости от корректности пути
- *Known Paht/ Known Root Type* --- неизменяемая ссылка на поле структуры
- *Value/Reference Mutation Semantics* --- изменяемая ссылка на поле структуры

Кроме малозначимых итераций @kp3@kp4, был принято предложение по развитию языка, позволяющее работать с KeyPath выражением, как с функциональным типом. @kp5 Особенностью этого предложения было решение о том, что все эффекты порождаемые замыканиями KeyPath будут высчитываться в момент построения замыкания, вместо каждого вызова. Делая таким образом результирующую функцию чище.
```swift
var nextIndex = 0
func makeIndex() -> Int {
  defer { nextIndex += 1 }
  return nextIndex
}

// Calls makeIndex(), gets 0, forms \Array<Int>.[0]
let getFirst: ([Int]) -> Int = \Array<Int>.[makeIndex()]
// Calls makeIndex(), gets 1, forms \Array<Int>.[1]
let getSecond: ([Int]) -> Int = \Array<Int>.[makeIndex()]

assert(getFirst([1, 2, 3]) == 1) // it always returns root[0].
assert(getFirst([1, 2, 3]) == 1) // it always returns root[0].

assert(getSecond([1, 2, 3]) == 2) // it always returns root[1].
assert(getSecond([1, 2, 3]) == 2) // it always returns root[1].
```

Таким образом, в Swift имеется типобезопасная `Lens`/`Affine` "Оптика", работающая как с полями, так и с `property` (В Swift нет различия между этими понятиями с точки зрения ABI), указавшая на проблему с эффектами при построении композиции и предложившая вариант борьбы с ними.

Стоит заметить, что данная "Оптика" является очень быстрой, так как оперирует только с полями и в сущности, является оберткой над указателем.

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[интегрировать «Оптику» в язык Cangjie, достигнув сопоставимой производительности между кодом с «Оптикой» и аналогичным кодом её не использующим.]

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Выбрать модель «Оптики», учитывая особенности языка Cangjie],
    [Реализовать генерацию «Оптики» для структур данных],
    [Предоставить пользовательский интерфейс для работы с полученной моделью],
    [Провести тест производительности конечного решения]
)
