#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением описанных нами ранее проблем в языке. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будет рассмотрены: @optics, как формальная модель; некоторые из академических реализаций; а также существующие реализации в промышленных языках программирования. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков
== Мономорфная/Полиморфная оптика
== Иерархия оптики
== Всякие ФПшные термины. Higher-kind polimorphysm, deforestation, defunctionalization, yadda, yadda, yadda
== Анализ существующей реализации "Оптики"
=== Академические реализации
==== Getter/Setter
==== Van Laarhoven
==== Profunctor
=== Оптика в объектно-ориентированных языках
==== Kotlin Arrow
==== Scala Monocle
=== Оптика в функциональныч языках
==== Haskell lens
==== Haskell Optics
==== Haskell uniplate
=== Swift KeyPath
=== Analysis summary
== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оптики

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ требований],
    [Выбрать подход к решению на основе базового случая],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
