#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением сформулированных нами задач. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будут рассмотрены: @optics, как модель; академические реализации; а также существующие реализации в промышленных языках программирования. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков в @cangjie.

Для множества академических реализаций, от языков требуются достаточно продвинутые возможности... #TODO[]
== Формальное описание "Оптики"

@optics может быть представлена, как интерфейс из двух функций. Одна описывает -- как извлечь данные из структуры. Другая -- как заменить данные, извлеченные первой функцией на их модифицированную версию. Учитывая разнородность данных, с которыми может взаимодействовать разработчик, естественно предположить существование различных *видов "Оптики"*, специализирующихся на конкретных видах данных. Каждый вид "оптики" может быть задан полиморфным типом следующего вида: 

#noindent[
#align(center)[
`type Optic id a b s t`
#align(left)[где: #list(
  [`id` --- Идентификатор вида "Оптики"],
  [`s`  --- Тип обрамляющей стуркуты],
  [`a`  --- Тип значения лежащего в структуре],
  [`b`  --- Тип модифицированного значения],
  [`t`  --- Тип обрамляющей структуры, хранащей модифицированное значение],
  marker: [-]
)]
]]

Частным случаем #gls("optics", display: ["Оптики"]) является *мономорфная "Оптика"*.
#definition([Мономорфная "Оптика"])[Объект "Оптики", который не меняет типы значения и обрамляющей её структуры. То есть `s` = `t` и `a` = `b`]

Она предоставляет для нас особенный интерес, по причине простоты вывода типов. Так как язык @cangjie является объектно-ориентированным и в нем присутствует отношение подтипизации на типах, то весь вывод типов у нас локальный. Из этого следует, что в месте применения #gls("optics", display: ["Оптики"]) нам необходимо знать уже все типы `a`, `b`, `s`, `t`. Что в общем случае нельзя сделать, не имея глобального вывода типов и полиморфных переменных. #TODO[пояснить в чем именно проблема. Лучше даже на примерах. Возможно, стоит вынести эти дебаты про выводимость куда-то в другое место]
// Существование объекта "Оптики" равносильно доказательсту некого утверждения о взаимоотношении типов, указанных в сигнатуре оптики.
// 
// В данном контексте существование мономорфной "Оптики" является доказательством основного утверждения для типов `s` и `a`. А возможность её расширения до полиморфной гласит о том, что утверждение остается верным для типов `t` и `b` после перехода к ним некой функцией `(a -> b) -> s -> t`. #TODO[А точно ли это правда?]

=== Виды "Оптики"
Рассмотрим несколько классических видов #gls("optics", display: ["Оптики"]). #TODO[Вставь сюда что-то про то, о чем будет речь]. Для простоты, все дальнейшее обсуждение будет в контексте мономорфной "Оптики". Чтобы перейти к сигнатурам методов для полиморфной оптики нужно:
#list(
    [Заменить тип `s` на тип `t` в ковариантных позициях],
    [Заменить тип `a` на тип `b` в контрaвариантных позициях]
)

==== Изоморфизм (Iso)
Самый простой из всех видов "Оптики". Как следует из названия, существование объекта такого вида, утверждает, что типы `s` и `a` хранят под собой одну и ту же информацию, но предствленную в различном виде. *Iso* описывает то, как перейти из одного представления в другое и обратно. Интерефейс состоит из следующих двух функций:
#noindent[
#align(center)[
    #block[#align(left)[
    `to :: s -> a`

    `from :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `to :: s -> a`
// 
//     `from :: t -> b`
//     ]]
// ]
]

#TODO[тут надо сказать что-то еще, про полезности. Например `coerce`]
==== Линза (Lens)
Пожалуй, самый распространенный из всех видов "Оптики". Пусть `s` -- тип-произведение, тогда тип `a` -- одна из составных частей этого типа. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `view :: s -> a`

    `update :: (s, a) -> s`
    ]]
]
Сигнатура и поведение методов очевидно. Достаем часть `a` структуры `s` через метод `view`, Заменяем часть `a` переданной на вход структуры `s` на имеющуюсяя часть `a` с помощью метода `update`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `view :: s -> a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]
]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Призма (Prism)
Пусть `s` -- тип-сумма, тогда тип `a` -- один из возможных типов, который может скрываться за типом `s`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `build :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `build :: b -> t`
//     ]]
// ]
]

#TODO[тут абсолютно точно надо что-то сказать. Потому что призма не до конца очевидна. Особенно если сравнивать её с Affine]
==== Affine
Комбинация двух предыдущих видов "Оптики". Пусть `s` -- тип-сумма типов-произведений, тогда тип `a` составная часть некоторых из типов-произведений. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `update :: (s, a) -> s`
    ]]
]

Стоит заметить, что здесь, несмотря на то, что синганура метода `update` выглядит также, его семантика изменилась в сравнении с линзой. Метод `update` у линзы всегда проходил успешно и модифицировал структуру данных. Здесь же, сначала идет проверка, что переданный аргумент типа `s` действительно имеет `a`, как свою составную часть. И если это так, то происходит замена на новое значение типа `a`, иначе -- возвращаем `s` без изменений
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Traversal
Расширение предыдущей "Оптики". Affine можно альтернативно интерпретировать, как то, что в нашем объекте `s` хранится либо 0 либо 1 экземпляр типа `a`. Тогда Traversal говорит нам, что объект `s` может хранить в себе произвольное количество экземпляров типа `a`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `toList :: s -> [a]`

    `over :: (a -> a) -> s -> s`
    ]]
]
Объект описывает способ достижения и порядок обхода всех экземпляров типа `a`, которые можно извлечь из объекта `s`.
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `toList :: s -> [a]`
//
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Setter
Отдельный вид "Оптики". В отличие от всех описанных ранее видов, определяется одним единственным методом `over`:
#noindent[
#align(center)[
    #block[#align(left)[
    `over :: (a -> a) -> s -> s`
    ]]
]
Фокусируется на произвольные значения типа `a`, хранимые в структуре, позволяя нам, перед этим, добавить свое преобразование `a -> a`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
]

=== Иерархия "Оптики", законы и композиция
// Описанный нами выше набор "Оптик" не является полным, однако, демонстрирует в достаточной мере суть абстракции. Ранее, мы выделили 3 основных свойства "Оптики", которые мы считаем важными: Персистентный интерфейс, композируемость и объект первого класса. Формально это достигается через другие свойства "Оптики", которые мы рассмотрим.
Можно заметить, что различные оптики, перекрывают своей функциональностью друг друга. Так, например, очевидно, что `Lens` это `Affine`, который всегда сфокусирован на одном значении. Или, например, `Setter` -- самая общая и гибкая "Оптика", позволяющая модифицировать данные. Ниже приведена диаграмма, отображающая иерархию наследования между видами "Оптики".

#figure(
  image("../attachments/figures/hierarchy.png", width: 45%),
  caption: [ Диаграмма иерархии #gls("optics", display: ["Оптики"])]
)
#noindent[
Приведенная иерархия не является полной и может быть расширена @bigger_hierarchy. Хотя `Setter` достаточно для всех задач, использование более специализированных "Оптик" дает преимущество наличия различных типовых гарантий. Эти типовые гарантии выражаются в виде существования значений для извлечения, их количества и т.д. Также есть *законы "Оптики"* -- набор правил, удовлетворение которым гарантирует отсутствие эффектов и предсказуемое поведение. Пример законов для линзы:
  #align(center)[
    #block[#align(left)[
      #enum(
        [`set l (get l s) s = s`],
        [`get l (set l a s) = a`],
        [`set l a' (set l a s) = set l a' s`],
      )
    ]]
  ]
  Полный набор законов, для всех видов "Оптики" описан в реализациях различных библиотек @haskell_lib. Законы позволяют интерпретировать поведение оптики логичным и ожидаемым образом, предотвращают ошибки, которые могут быть связаны, например, с утратой данных, а также соблюдение законов позволяет производить оптимизации для предотвращения лишних вычислений. "Оптику", удовлетворяющую своим законам, мы будем называть *семантически корректной*.
]

#definition([Семантически корректная "Оптикa"])["Оптика", удовлетворяющая законам соответствующим своему виду]

  
"Оптика", по своему определению, способна к композируемости. Обычно это делается путем предоставления специальной функции `compose` или оператора с подобной сигнатурой:
#noindent[
#align(center)[
    #block[#align(left)[
            ```haskell

            class Compose id1 id2 id3 | id1 id2 -> id3 where
              compose :: Optic id1 u s -> Optic id2 a u -> Optic id3 a s
            ```
    ]]
]
Композируя различные виды "Оптики", мы получаем новый объект, вид которого однозначно определяется видами композируемых "Оптик", а именно, наименьший общий предок в иерархии. Например: композиция Lens и Prism возвращает нам Affine. В исключительных случаях "Оптики" не могут быть скомпозированы друг с другом, так как находятся в разных частях иерархии и не имеют общих предков. Например: `Getter` и `Setter`.
]
Также, важным свойством композиции является сохранение семантической корректности. Если оба объекта "Оптики" были построены сематнически корректно, то и результат их композиции останется семантически корректной. 
=== Модели "Оптики"
Существует множество моделей, с помощью которых можно реализовать описанный нами выше интерфейс и его поведение. Самая очевидная из них -- пара `getter`/`setter` функций, хранящихся в типе-записи, в точности отражающей API "Оптики".

Существует множество других реализаций, однако они требуют достаточно продвинутых возможностей от языка, таких как: Экзистенциальные типы, Higher-kinded полиморфизм, High-rank типы, классы типов
==== Экзистенциальная модель
```haskell

type Optic a s = exists c. (s -> (c, a), (c, a) -> s)
```
Наиболее наглядная из всех моделей. Идея заключается в разбиении структуры данных на две части: Часть на которую объект "сфокусирован" и некий объект типа `c`, с помощью которого мы можем собрать новый объект с только измененным куском `a`.

Модель, в неком смысле является обобщением упомянутой выше `getter`/`setter` модели. Ведь действительно, в случае `Lens`, один из вариантов --- тип `c` равен типу `s` 

```haskell

type Lens a s = (s -> (s, a), (s, a) -> s)
```

Однако, заметных преимуществ у данной модели, в сравнении с предыдущей нет. А экзистенциальные типы могут предоставить далеко не все языки, к коим @cangjie не относится.
==== Модель ван Лаарховена
Альтернативный подход, идея которого заключается в определении "Оптики" через ограничения на функтор. И выбор одной из двух функций, на основе функтора удовлетворяющего ограничению. @cps_refs
```haskell

type Optic a s = forall f. Functor f => (a -> f a) -> (s -> f s)
```
Одним из основных преимуществ является упрощение инлайнинга за счет того, что композиция "Оптики" эквивалентна композиции функций высших порядков, вместо построения новых типов-записей на основе других типов-записей.

Для реализации, языку требуется наличие Higher-kinded полиморфизма или его имитация. Для достижения first-class нужен глобальный вывод типов. Иерархия строится с помощью пересечения/объединения ограничений на классы типов функтора.

Однако, существует проблема относительно выразимости "Оптики", оперирующей типами-суммами (такими, как `Affine` и `Prism`) с возможностью их композиромостью. Библиотеки, основанные на данной модели "Оптики" обходят эту проблему путем реализации соответствующих видов "Оптики" через профункторы. @kmett_prism 
==== Модель профункторов (Profunctor Optics)
Обобщение модели ван Лаарховена, с целью решить проблему выразимости "Оптики", оперирующей типами-суммами. Основная идея заключается в замене функциональной стрелки, на её обобщение - профунктор:
```haskell

type Optic a s = forall p. Profunctor p => p a a -> p s s
```

Реализация, также, как и в случае с van Laarhoven, требует от языка наличия Higher-kinded полиморфизма, глобального вывода типов и классов типов.

Так как набор требований к возможностям языка, у модели ван Лаарховена и модели профункторов совпадает, то мы не будем останавливаться на ней в деталах. Если сможем реализовать предыдущую модель, то сможем реализовать и модель профункторов. Детальная реализация на haskell описывается в соответствующих статьях. @modular_acc
=== Оптика в объектно-ориентированных языках
Все существующие реализации "Оптики" в языках, в той или иной мере ориентируются на описанные выше модели:
- Модель `getter`/`setter` --- самая распространенная и некоторые примеры мы рассмотрим детальнее.
- Модель ван Лаарховена используется как основа для библиотеки lens в Haskell @kmett_lib
- Модель профункторов можно увидеть в библиотеках Optics @haskell_lib и Fresnel @fresnel_lib

Однако имеет смысл рассмотреть не только абстрактные модели и их реализации в функциональных языках, но и существующие реализации в других языках программирования, в надежде перенести их с наименьшей затратой усилий.

Среди промышленных языков, одними из самых популярных реализации "Оптики", можно назвать библиотеки в Kotlin и Scala. а также Swift KeyPath --- функциональность языка, являющаяся реализацией `Lens`/`Affine` встроенной напрямую в синтаксис и систему типов.
==== Kotlin Arrow
#TODO[]
==== Scala Monocle
#TODO[]
=== Swift KeyPath
Функциональность языка, пережившая несколько итераций, перед тем, как стать чем-то похожим на "Оптику". Изначально представляла собой специальный строковый литерал, который во время компиляции проверял существование указанных полей в обращаемой структуре. @kp1
```swift

let chris = Person(firstName: "Chris", lastName: "Lattner")
#keyPath(Person.firstName) // => "firstName"
chris.valueForKey(#keyPath(Person.firstName)) // => Chris
```
Во второй итерации была введены несколько видов KeyPath, различающихся в своих типовых гарантиях и специальное выражение вида: `\Type.chain.of.accessors`. @kp2
- *Unknown Path/Unknown Root Type* --- Введен для обратной совместимости с ObjectiveC, который не хранит никакой информации о корректности пути. Проходит компиляцию всегда
- *Unknown Path/Known Root Type* --- Проходит компиляцию, если оперируем над объектом нужного типа, вне зависимости от корректности пути
- *Known Paht/ Known Root Type* --- неизменяемая ссылка на поле структуры
- *Value/Reference Mutation Semantics* --- изменяемая ссылка на поле структуры

Кроме малозначимых итераций @kp3@kp4, был принято предложени по развитию языка, позволяющее работать с KeyPath выражением, как с функциональным типом. @kp5 Особенностью этого предложения было решение о том, что все эффекты порождаемые замыканиями KeyPath будут высчитываться в момент построения замыкания, вместо каждого вызова. Делая таким образом результирующую функцию чище.
```swift
var nextIndex = 0
func makeIndex() -> Int {
  defer { nextIndex += 1 }
  return nextIndex
}

// Calls makeIndex(), gets 0, forms \Array<Int>.[0]
let getFirst: ([Int]) -> Int = \Array<Int>.[makeIndex()]
// Calls makeIndex(), gets 1, forms \Array<Int>.[1]
let getSecond: ([Int]) -> Int = \Array<Int>.[makeIndex()]

assert(getFirst([1, 2, 3]) == 1) // it always returns root[0].
assert(getFirst([1, 2, 3]) == 1) // it always returns root[0].

assert(getSecond([1, 2, 3]) == 2) // it always returns root[1].
assert(getSecond([1, 2, 3]) == 2) // it always returns root[1].
```

Таким образом, в Swift имеется типобезопасная `Lens`/`Affine` "Оптика", работающая как с полями, так и с `property` (В Swift нет различия между этими понятиями с точки зрения ABI), указавшая на проблему с эффектами при построении композиции и предложившая вариант борьбы с ними.

Стоит заметить, что данная "Оптика" является очень быстрой, так как оперирует только с полями и в сущности, является "умным" указателем.

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оной 

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Выбрать подход к решению на основе базового сценария],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
