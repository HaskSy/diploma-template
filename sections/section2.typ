#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением сформулированных нами задач. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будут рассмотрены: @optics, как модель; академические реализации; а также существующие реализации в промышленных языках программирования. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков в @cangjie.

Для множества академических реализаций, от языков требуются достаточно продвинутые возможности... #TODO[]
== Формальное описание "Оптики"

@optics может быть представлена, как интерфейс из двух функций. Одна описывает -- как извлечь данные из структуры. Другая -- как заменить данные, извлеченные первой функцией на их модифицированную версию. Учитывая разнородность данных, с которыми может взаимодействовать разработчик, естественно предположить существование различных *видов "Оптики"*, специализирующихся на конкретных видах данных. Каждый вид "оптики" может быть задан полиморфным типом следующего вида: 

#noindent[
#align(center)[
`type Optic id a b s t`
#align(left)[где: #list(
  [`id` --- Идентификатор вида "Оптики"],
  [`s`  --- Тип обрамляющей стуркуты],
  [`a`  --- Тип значения лежащего в структуре],
  [`b`  --- Тип модифицированного значения],
  [`t`  --- Тип обрамляющей структуры, хранащей модифицированное значение],
  marker: [-]
)]
]]

Частным случаем #gls("optics", display: ["Оптики"]) является *мономорфная "Оптика"*.
#definition([Мономорфная "Оптика"])[Объект "Оптики", который не меняет типы значения и обрамляющей её структуры. То есть `s` = `t` и `a` = `b`]

Она предоставляет для нас особенный интерес, по причине простоты вывода типов. Так как язык @cangjie является объектно-ориентированным и в нем присутствует отношение подтипизации на типах, то весь вывод типов у нас локальный. Из этого следует, что в месте применения #gls("optics", display: ["Оптики"]) нам необходимо знать уже все типы `a`, `b`, `s`, `t`. Что в общем случае нельзя сделать, не имея глобального вывода типов и полиморфных переменных. #TODO[пояснить в чем именно проблема. Лучше даже на примерах. Возможно, стоит вынести эти дебаты про выводимость куда-то в другое место]
// Существование объекта "Оптики" равносильно доказательсту некого утверждения о взаимоотношении типов, указанных в сигнатуре оптики.
// 
// В данном контексте существование мономорфной "Оптики" является доказательством основного утверждения для типов `s` и `a`. А возможность её расширения до полиморфной гласит о том, что утверждение остается верным для типов `t` и `b` после перехода к ним некой функцией `(a -> b) -> s -> t`. #TODO[А точно ли это правда?]

=== Виды "Оптики"
Рассмотрим несколько классических видов #gls("optics", display: ["Оптики"]). *Вставь сюда что-то про то, о чем будет речь*. Для простоты, все дальнейшее обсуждение будет в контексте мономорфной "Оптики". Чтобы перейти к сигнатурам методов для полиморфной оптики нужно:
#list(
    [Заменить тип `s` на тип `t` в ковариантных позициях],
    [Заменить тип `a` на тип `b` в контрaвариантных позициях]
)

==== Изоморфизм (Iso)
Самый простой из всех видов "Оптики". Как следует из названия, существование объекта такого вида, утверждает, что типы `s` и `a` хранят под собой одну и ту же информацию, но предствленную в различном виде. *Iso* описывает то, как перейти из одного представления в другое и обратно. Интерефейс состоит из следующих двух функций:
#noindent[
#align(center)[
    #block[#align(left)[
    `to :: s -> a`

    `from :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `to :: s -> a`
// 
//     `from :: t -> b`
//     ]]
// ]
]

#TODO[тут надо сказать что-то еще, про полезности. Например `coerce`]
==== Линза (Lens)
Пожалуй, самый распространенный из всех видов "Оптики". Пусть `s` -- тип-произведение, тогда тип `a` -- одна из составных частей этого типа. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `view :: s -> a`

    `update :: (s, a) -> s`
    ]]
]
Сигнатура и поведение методов очевидно. Достаем часть `a` структуры `s` через метод `view`, Заменяем часть `a` переданной на вход структуры `s` на имеющуюсяя часть `a` с помощью метода `update`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `view :: s -> a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]
]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Призма (Prism)
Пусть `s` -- тип-сумма, тогда тип `a` -- один из возможных типов, который может скрываться за типом `s`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `build :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `build :: b -> t`
//     ]]
// ]
]

#TODO[тут абсолютно точно надо что-то сказать. Потому что призма не до конца очевидна. Особенно если сравнивать её с Affine]
==== Affine
Комбинация двух предыдущих видов "Оптики". Пусть `s` -- тип-сумма типов-произведений, тогда тип `a` составная часть некоторых из типов-произведений. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `update :: (s, a) -> s`
    ]]
]

Стоит заметить, что здесь, несмотря на то, что синганура метода `update` выглядит также, его семантика изменилась в сравнении с линзой. Метод `update` у линзы всегда проходил успешно и модифицировал структуру данных. Здесь же, сначала идет проверка, что переданный аргумент типа `s` действительно имеет `a`, как свою составную часть. И если это так, то происходит замена на новое значение типа `a`, иначе -- возвращаем `s` без изменений
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Traversal
Расширение предыдущей "Оптики". Affine можно альтернативно интерпретировать, как то, что в нашем объекте `s` хранится либо 0 либо 1 экземпляр типа `a`. Тогда Traversal говорит нам, что объект `s` может хранить в себе произвольное количество экземпляров типа `a`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `toList :: s -> [a]`

    `over :: (a -> a) -> s -> s`
    ]]
]
Объект описывает способ достижения и порядок обхода всех экземпляров типа `a`, которые можно извлечь из объекта `s`.
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `toList :: s -> [a]`
//
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
==== Setter
Отдельный вид "Оптики". В отличие от всех описанных ранее видов, определяется одним единственным методом `over`:
#noindent[
#align(center)[
    #block[#align(left)[
    `over :: (a -> a) -> s -> s`
    ]]
]
Фокусируется на произвольные значения типа `a`, хранимые в структуре, позволяя нам, перед этим, добавить свое преобразование `a -> a`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]
// ]

#TODO[тут надо сказать что-то про полезности/примеры]
]

=== Иерархия "Оптики", законы и композиция
// Описанный нами выше набор "Оптик" не является полным, однако, демонстрирует в достаточной мере суть абстракции. Ранее, мы выделили 3 основных свойства "Оптики", которые мы считаем важными: Персистентный интерфейс, композируемость и объект первого класса. Формально это достигается через другие свойства "Оптики", которые мы рассмотрим.
Можно заметить, что различные оптики, перекрывают своей функциональностью друг друга. Так, например, очевидно, что `Lens` это `Affine`, который всегда сфокусирован на одном значении. Или, например, `Setter` -- самая общая и гибкая "Оптика", позволяющая модифицировать данные. Ниже приведена диаграмма, отображающая иерархию наследования между видами "Оптики".

#figure(
  image("../attachments/figures/hierarchy.png", width: 45%),
  caption: [ Диаграмма иерархии #gls("optics", display: ["Оптики"])]
)
#noindent[
Приведенная иерархия не является полной и может быть расширена @bigger_hierarchy. Хотя `Setter` достаточно для всех задач, использование более специализированных "Оптик" дает преимущество наличия различных типовых гарантий. Эти типовые гарантии выражаются в виде существования значений для извлечения, их количества и т.д. Также есть *законы "Оптики"* -- набор правил, удовлетворение которым гарантирует отсутствие эффектов. Пример законов для линзы:
  #align(center)[
    #block[#align(left)[
      #enum(
        [`set l (get l s) s = s`],
        [`get l (set l a s) = a`],
        [`set l a' (set l a s) = set l a' s`],
      )
    ]]
  ]
  Полный набор законов, для всех видов "Оптики" описан в реализациях различных библиотек @haskell_lib. Законы позволяют интерпретировать поведение оптики логичным и ожидаемым образом, предотвращают ошибки, которые могут быть связаны, например, с утратой данных, а также соблюдение законов позволяет производить оптимизации для предотвращения лишних вычислений. "Оптику", удовлетворяющую своим законам, мы будем называть *семантически корректной*.
]

#definition([Семантически корректная "Оптикa"])["Оптика", удовлетворяющая законам соответствующим своему виду]

#noindent[
  #TODO[Рассказать про композицию]
]
=== Академические реализации
#TODO[]
==== Getter/Setter
#TODO[]
==== Van Laarhoven
#TODO[]
==== Profunctor
#TODO[]
=== Оптика в объектно-ориентированных языках
#TODO[]
==== Kotlin Arrow
#TODO[]
==== Scala Monocle
#TODO[]
=== Swift KeyPath
#TODO[]
== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оной 

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ требований],
    [Выбрать подход к решению на основе базового случая],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
