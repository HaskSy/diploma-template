#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением сформулированных нами задач. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будут рассмотрены: @optics, как модель; академические реализации; а также существующие реализации в промышленных языках программирования. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков в @cangjie.

Для множества академических реализаций, от языков требуются достаточно продвинутые возможности... TODO
== Виды "Оптики" и иерархия

@optics может быть представлена, как интерфейс из, обычно, одной-двух функций, описывающих некую цепочку обработки данных. Каждый вид оптики может быть задан полиморфным типом следующего вида: 
#figure(
`type Optic id a b s t`
)
где: TODO formatting
- `id` --- Идентификатор оптики
- `s` --- тип входной стуркуты
- `a` --- тип значения из входной струкруты
- `t` --- тип выходной стуркуты
- `b` --- тип значения из выходной струкруты

Частным случаем #gls("optics", display: ["Оптики"]) является *мономорфная "Оптика"*. Мы будем называть #gls("optics", display: ["Оптику"]) мономорфной, если `s` = `t` и `a` = `b`. Она предоставляет для нас особенный интерес, по причине простоты вывода типов. Так как язык @cangjie является объектно-ориентированным и в нем присутствует отношение подтипизации на типах, то весь вывод типов у нас локальный. Из этого следует, что в месте применения #gls("optics", display: ["Оптики"]) нам необходимо знать уже все типы `a`, `b`, `s`, `t`. Что в общем случае нельзя сделать, не имея глобального вывода типов и полиморфных переменных. Основная проблема в ковариантных параметрах `a` и `t`.

Существование объекта "Оптики" равносильно доказательсту некого утверждения о взаимоотношении типов, указанных в сигнатуре оптики.

В данном контексте существование мономорфной "Оптики" является доказательством основного утверждения для типов `s` и `a`. А возможность её расширения до полиморфной гласит о том, что утверждение остается верным для типов `t` и `b` после перехода к ним некой функцией `(a -> b) -> s -> t`// (Это, кстати `Setter`) 

// #definition([Мономорфная "Оптика"])[Вид оптики, у которого тип входной и выходной структуры совпадают]

Далее, рассмотрим несколько классических видов #gls("optics", display: ["Оптики"]):

- *Изоморфизм (Iso)* --- самый простой из всех видов "Оптики". Обявление такого объекта доказывает нам, что типы данны

#figure(
  image("../attachments/figures/hierarchy.png", width: 45%),
  caption: [ Диаграмма иерархии #gls("optics", display: ["Оптики"])]
)

== Всякие ФПшные термины. Higher-kind polimorphysm, deforestation, defunctionalization, yadda, yadda, yadda
== Анализ существующих реализации "Оптики"
=== Академические реализации
==== Getter/Setter
==== Van Laarhoven
==== Profunctor
=== Оптика в объектно-ориентированных языках
==== Kotlin Arrow
==== Scala Monocle
=== Оптика в функциональныч языках
==== Haskell lens
==== Haskell Optics
==== Haskell uniplate
=== Swift KeyPath
=== Analysis summary
== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оптики

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ требований],
    [Выбрать подход к решению на основе базового случая],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
