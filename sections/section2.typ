#import "../lib.typ": *

= Анализ предметной области "Оптики"
В предыдущей главе мы постулировали, что @optics является решением сформулированных нами задач. В данной главе мы рассмотрим #gls("optics", display: ["Оптику"]) более формально. Будут рассмотрены: @optics, как модель; академические реализации; а также существующие реализации в промышленных языках программирования. Это, во-первых, позволит нам понять, с какими ограничениями системы типов @cangjie мы можем столкнуться. Во-вторых, определить переносимость существующих решений из других промышленных языков в @cangjie.

Для множества академических реализаций, от языков требуются достаточно продвинутые возможности... TODO
== Формальное описание "Оптики"

@optics может быть представлена, как интерфейс из, обычно, одной-двух функций, описывающих некую цепочку обработки данных. Каждый вид оптики может быть задан полиморфным типом следующего вида: 
#align(center)[
`type Optic id a b s t`
]

#noindent[где:
#list(
  [`id` --- Идентификатор вида "Оптики"],
  [`s`  --- Тип входной стуркуты],
  [`a`  --- Тип значения из входной струкруты],
  [`t`  --- Тип выходной стуркуты],
  [`b`  --- Тип значения из выходной струкруты],
  marker: [-]
)
]

Частным случаем #gls("optics", display: ["Оптики"]) является *мономорфная "Оптика"*. Мы будем называть #gls("optics", display: ["Оптику"]) мономорфной, если `s` = `t` и `a` = `b`. Она предоставляет для нас особенный интерес, по причине простоты вывода типов. Так как язык @cangjie является объектно-ориентированным и в нем присутствует отношение подтипизации на типах, то весь вывод типов у нас локальный. Из этого следует, что в месте применения #gls("optics", display: ["Оптики"]) нам необходимо знать уже все типы `a`, `b`, `s`, `t`. Что в общем случае нельзя сделать, не имея глобального вывода типов и полиморфных переменных. #TODO[пояснить в чем именно проблема. Лучше даже на примерах]

Существование объекта "Оптики" равносильно доказательсту некого утверждения о взаимоотношении типов, указанных в сигнатуре оптики.

В данном контексте существование мономорфной "Оптики" является доказательством основного утверждения для типов `s` и `a`. А возможность её расширения до полиморфной гласит о том, что утверждение остается верным для типов `t` и `b` после перехода к ним некой функцией `(a -> b) -> s -> t`. #TODO[А точно ли это правда?]

// #definition([Мономорфная "Оптика"])[Вид оптики, у которого тип входной и выходной структуры совпадают]
=== Виды "Оптики" и иерархия
Рассмотрим несколько классических видов #gls("optics", display: ["Оптики"]). *Вставь сюда что-то про то, о чем будет речь*. Для простоты, все дальнейшее обсуждение будет в контексте мономорфной "Оптики". Чтобы перейти к сигнатурам методов для полиморфной оптики нужно:
#list(
    [Заменить тип `s` на тип `t` в ковариантных позициях],
    [Заменить тип `a` на тип `b` в контрaвариантных позициях]
)

==== Изоморфизм (Iso)
Самый простой из всех видов "Оптики". Существование объекта такого типа, утверждает, что типы `s` и `a` хранят под собой одну и ту же информацию, но предствленную в различном виде. *Iso* описывает то, как перейти из одного представления в другое и обратно. Интерефейс состоит из следующих двух функций:
#noindent[
#align(center)[
    #block[#align(left)[
    `to :: s -> a`

    `from :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `to :: s -> a`
// 
//     `from :: t -> b`
//     ]]
// ]
]

#TODO[тут надо сказать что-то еще, про полезности. Например `coerce`]
==== Линза (Lens)
Пожалуй, самый распространенный из всех видов "Оптики". Пусть `s` -- тип-произведение, тогда тип `a` -- одна из составных частей этого типа. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `view :: s -> a`

    `update :: (s, a) -> s`
    ]]
]
Сигнатура и поведение методов очевидно. Достаем часть `a` структуры `s` через метод `view`, Заменяем часть `a` переданной на вход структуры `s` на имеющуюсяя часть `a` с помощью метода `update`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `view :: s -> a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]
]

#TODO[тут надо сказать что-то про полезности.]
==== Призма (Prism)
Пусть `s` -- тип-сумма, тогда тип `a` -- один из возможных типов, который может скрываться за типом `s`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `build :: a -> s`
    ]]
]
// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `build :: b -> t`
//     ]]
// ]
]

#TODO[тут абсолютно точно надо что-то сказать. Потому что призма не до конца очевидна. Особенно если сравнивать её с Affine]
==== Affine
Комбинация двух предыдущих видов "Оптики". Пусть `s` -- тип-сумма типов-произведений, тогда тип `a` составная часть некоторых из типов-произведений. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `preview :: s -> Either s a`

    `update :: (s, a) -> s`
    ]]
]

Стоит заметить, что здесь, несмотря на то, что синганура метода `update` выглядит также, его семантика изменилась в сравнении с линзой. Метод `update` у линзы всегда проходил успешно и модифицировал структуру данных. Здесь же, сначала идет проверка, что переданный аргумент типа `s` действительно имеет `a`, как свою составную часть. И если это так, то происходит замена на новое значение типа `a`, иначе -- возвращаем `s` без изменений
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `preview :: s -> Either t a`
// 
//     `update :: (s, b) -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности.]
==== Traversal
Расширение предыдущей "Оптики". Affine можно альтернативно интерпретировать, как то, что в нашем объекте `s` хранится либо 0 либо 1 экземпляр типа `a`. Тогда Traversal говорит нам, что объект `s` может хранить в себе произвольное количество экземпляров типа `a`. Интерфейс методов:
#noindent[
#align(center)[
    #block[#align(left)[
    `toList :: s -> [a]`

    `over :: (a -> a) -> s -> s`
    ]]
]
Объект описывает способ достижения и порядок обхода всех экземпляров типа `a`, которые можно извлечь из объекта `s`.
]

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `toList :: s -> [a]`
//
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]

#TODO[тут надо сказать что-то про полезности.]
==== Setter
Отдельный вид "Оптики". В отличие от всех описанных ранее видов, определяется одним единственным методом `over`:
#noindent[
#align(center)[
    #block[#align(left)[
    `over :: (a -> a) -> s -> s`
    ]]
]
Фокусируется на произвольные значения типа `a`, хранимые в структуре, позволяя нам, перед этим, добавить свое преобразование `a -> a`.

// В случае полиморфной оптики соответствующие сигнатуры:
// #align(center)[
//     #block[#align(left)[
//     `over :: (a -> b) -> s -> t`
//     ]]
// ]
// ]

#TODO[тут надо сказать что-то про полезности.]
]


#figure(
  image("../attachments/figures/hierarchy.png", width: 45%),
  caption: [ Диаграмма иерархии #gls("optics", display: ["Оптики"])]
)

== Всякие ФПшные термины. Higher-kind polimorphysm, deforestation, defunctionalization, yadda, yadda, yadda
== Анализ существующих реализации "Оптики"
=== Академические реализации
==== Getter/Setter
==== Van Laarhoven
==== Profunctor
=== Оптика в объектно-ориентированных языках
==== Kotlin Arrow
==== Scala Monocle
=== Оптика в функциональныч языках
==== Haskell lens
==== Haskell Optics
=== Swift KeyPath
=== Analysis summary
== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оной 

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ требований],
    [Выбрать подход к решению на основе базового случая],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
