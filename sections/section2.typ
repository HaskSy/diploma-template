#import "../lib.typ": *

= "Оптика"
#definition("«Оптика»")[
    Абстракция, хранащая информацию о способе доступа, модификации, обхода сложных структур данных
]

В литературе, @optics также встречается под названием *bidirectional transformation (bx)*, как их частный случай @database_views@pierce_framework.

@optics, в том виде, в котором она пришла из функционального программирования, решала задачу построения новых версий сложных неизменяемых структур данных, на основе предыдущих версий. Таким образом, добавление #gls("optics", display: ["Оптики"]), решило бы первые две проблемы языка по принципу её построения. Касательно проблемы View-Update, в соответствующих работах, были сформулированы идеи реализации View-Update фреймворка на базе механизма #gls("optics", display: ["Оптики"]) @pierce_framework.

Таким образом, мы постулируем, что @optics обязана удовлетворять следующим свойствам:
#list(
    [Композируемость],
    [Объект первого класса],
    [Персистентны интерфейс]
)

== Мономорфная/Полиморфная оптика
== Иерархия оптики
== Всякие ФПшные термины. Higher-kind polimorphysm, deforestation, defunctionalization, yadda, yadda, yadda

== Цель и задачи работы

#let goal(body) = {
    strong("Цель: ")
    body
}

#goal[Разработать мезанизм #gls("optics", display: ["Оптики"])] в языке @cangjie и сделать прототип, использование которого, сопоставимо по скорости с кодом, написанным без оптики

#let objectives(..obj) = {
    strong("Задачи: ")
    enum(..obj)
}

#objectives(
    [Провести анализ требований],
    [Выбрать подход к решению на основе базового случая],
    [Реализовать генерацию оптики],
    [Расширить механизм для пользовательской оптики],
    [Провалидировать полученное решение]
)
